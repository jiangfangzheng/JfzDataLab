// Copyright:	Jfz
// Author:		Sandeepin
// Date:		2017-07-23
// Description:	武重数据标准化算法

#if _MSC_VER >= 1600
	   #pragma execution_character_set("utf-8")
#endif

#include "DataProcessing.h"
#include "tools/JIO.h"
#include <vector>
#include <QDebug>
#include <armadillo>
#include <QFile>
using namespace arma;
using namespace std;

/********************1、【线性回归相关函数】********************/

// 功能：释放内存。
// dat：矩阵数组；
// d：临时变量；
// count：方程元数；
// 返回：void
void FreeData(double **dat, double *d, int count)
{
	int i;
	free(d);
	for (i = 0; i < count; i++)
		free(dat[i]);
	free(dat);
}

// 功能：解线性方程。
// data[count*(count+1)]：矩阵数组；
// count：方程元数；
// Answer[count]：求解数组 。
// 返回：0求解成功，-1无解或者无穷解
int LinearEquations(double *data, int count, double *Answer)
{
	int j, m, n;
	double tmp, **dat, *d = data;
	dat = (double**)malloc(count * sizeof(double*));
	for (m = 0; m < count; m++, d += (count + 1))
	{
		dat[m] = (double*)malloc((count + 1) * sizeof(double));
		memcpy(dat[m], d, (count + 1) * sizeof(double));
	}
	d = (double*)malloc((count + 1) * sizeof(double));
	for (m = 0; m < count - 1; m++)
	{
		// 如果主对角线元素为0，行交换
		for (n = m + 1; n < count && dat[m][m] == 0.0; n++)
		{
			if (dat[n][m] != 0.0)
			{
				memcpy(d, dat[m], (count + 1) * sizeof(double));
				memcpy(dat[m], dat[n], (count + 1) * sizeof(double));
				memcpy(dat[n], d, (count + 1) * sizeof(double));
			}
		}
		// 行交换后，主对角线元素仍然为0，无解，返回-1
		if (dat[m][m] == 0.0)
		{
			FreeData(dat, d, count);
			return -1;
		}
		// 消元
		for (n = m + 1; n < count; n++)
		{
			tmp = dat[n][m] / dat[m][m];
			for (j = m; j <= count; j++)
				dat[n][j] -= tmp * dat[m][j];
		}
	}
	for (j = 0; j < count; j++)
		d[j] = 0.0;
	// 求得count - 1的元
	Answer[count - 1] = dat[count - 1][count] / dat[count - 1][count - 1];
	// 逐行代入求各元
	for (m = count - 2; m >= 0; m--)
	{
		for (j = count - 1; j > m; j--)
			d[m] += Answer[j] * dat[m][j];
		Answer[m] = (dat[m][count] - d[m]) / dat[m][m];
	}
	FreeData(dat, d, count);
	return 0;
}

// 功能：求多元回归方程：Y = B0 + B1X1 + B2X2 + ...BnXn
// data[rows*cols]二维数组；X1i,X2i,...Xni,Yi (i=0 to rows-1)
// rows：数据行数；
// cols数据列数；
// Answer[cols]：返回回归系数数组(B0,B1...Bn)
// SquarePoor[4]：返回方差分析指标: 回归平方和，剩余平方和，回归平方差，剩余平方差
// 返回：0求解成功，-1错误
int MultipleRegression(double *data, int rows, int cols, double *Answer, double *SquarePoor)
{
	int m, n, i, count = cols - 1;
	double *dat, *p, a, b;
	if (data == 0 || Answer == 0 || rows < 2 || cols < 2)
		return -1;
	dat = (double*)malloc(cols * (cols + 1) * sizeof(double));
	dat[0] = (double)rows;
	for (n = 0; n < count; n++)                     // n = 0 to cols - 2
	{
		a = b = 0.0;
		for (p = data + n, m = 0; m < rows; m++, p += cols)
		{
			a += *p;
			b += (*p * *p);
		}
		dat[n + 1] = a;                              // dat[0, n+1] = Sum(Xn)
		dat[(n + 1) * (cols + 1)] = a;               // dat[n+1, 0] = Sum(Xn)
		dat[(n + 1) * (cols + 1) + n + 1] = b;       // dat[n+1,n+1] = Sum(Xn * Xn)
		for (i = n + 1; i < count; i++)             // i = n+1 to cols - 2
		{
			for (a = 0.0, p = data, m = 0; m < rows; m++, p += cols)
				a += (p[n] * p[i]);
			dat[(n + 1) * (cols + 1) + i + 1] = a;   // dat[n+1, i+1] = Sum(Xn * Xi)
			dat[(i + 1) * (cols + 1) + n + 1] = a;   // dat[i+1, n+1] = Sum(Xn * Xi)
		}
	}
	for (b = 0.0, m = 0, p = data + n; m < rows; m++, p += cols)
		b += *p;
	dat[cols] = b;                                   // dat[0, cols] = Sum(Y)
	for (n = 0; n < count; n++)
	{
		for (a = 0.0, p = data, m = 0; m < rows; m++, p += cols)
			a += (p[n] * p[count]);
		dat[(n + 1) * (cols + 1) + cols] = a;        // dat[n+1, cols] = Sum(Xn * Y)
	}
	n = LinearEquations(dat, cols, Answer);          // 计算方程式
													 // 方差分析
	if (n == 0 && SquarePoor)
	{
		b = b / rows;                                // b = Y的平均值
		SquarePoor[0] = SquarePoor[1] = 0.0;
		p = data;
		for (m = 0; m < rows; m++, p++)
		{
			for (i = 1, a = Answer[0]; i < cols; i++, p++)
				a += (*p * Answer[i]);               // a = Ym的估计值
			SquarePoor[0] += ((a - b) * (a - b));    // U(回归平方和)
			SquarePoor[1] += ((*p - a) * (*p - a));  // Q(剩余平方和)(*p = Ym)
		}
		SquarePoor[2] = SquarePoor[0] / count;       // 回归方差
		if (rows - cols > 0.0)
			SquarePoor[3] = SquarePoor[1] / (rows - cols); // 剩余方差
		else
			SquarePoor[3] = 0.0;
	}
	free(dat);
	return n;
}

// 功能：求多元回归方程的系数：Y = B0 + B1X1 + B2X2 + ...BnXn
// data[rows*cols]二维数组；X1i,X2i,...Xni,Yi (i=0 to rows-1)
// rows：数据行数；cols数据列数；
// Answer[cols]：返回回归系数数组(B0,B1...Bn)
// 返回：0求解成功，-1错误
int MultipleRegressionOnlyB(double *data, int rows, int cols, double *Answer)
{
	int m, n, i, count = cols - 1;
	double *dat, *p, a, b;
	if (data == 0 || Answer == 0 || rows < 2 || cols < 2)
		return -1;
	dat = (double*)malloc(cols * (cols + 1) * sizeof(double));
	dat[0] = (double)rows;
	for (n = 0; n < count; n++)                     // n = 0 to cols - 2
	{
		a = b = 0.0;
		for (p = data + n, m = 0; m < rows; m++, p += cols)
		{
			a += *p;
			b += (*p * *p);
		}
		dat[n + 1] = a;                              // dat[0, n+1] = Sum(Xn)
		dat[(n + 1) * (cols + 1)] = a;               // dat[n+1, 0] = Sum(Xn)
		dat[(n + 1) * (cols + 1) + n + 1] = b;       // dat[n+1,n+1] = Sum(Xn * Xn)
		for (i = n + 1; i < count; i++)             // i = n+1 to cols - 2
		{
			for (a = 0.0, p = data, m = 0; m < rows; m++, p += cols)
				a += (p[n] * p[i]);
			dat[(n + 1) * (cols + 1) + i + 1] = a;   // dat[n+1, i+1] = Sum(Xn * Xi)
			dat[(i + 1) * (cols + 1) + n + 1] = a;   // dat[i+1, n+1] = Sum(Xn * Xi)
		}
	}
	for (b = 0.0, m = 0, p = data + n; m < rows; m++, p += cols)
		b += *p;
	dat[cols] = b;                                   // dat[0, cols] = Sum(Y)
	for (n = 0; n < count; n++)
	{
		for (a = 0.0, p = data, m = 0; m < rows; m++, p += cols)
			a += (p[n] * p[count]);
		dat[(n + 1) * (cols + 1) + cols] = a;        // dat[n+1, cols] = Sum(Xn * Y)
	}
	n = LinearEquations(dat, cols, Answer);          // 计算方程式
	free(dat);
	return n;
}

// 功能：显示计算结果
// dat：二维数组，X1、X2……Y的矩阵；
// Answer[cols]：返回回归系数数组(B0,B1...Bn)
// SquarePoor[4]：返回方差分析指标: 回归平方和，剩余平方和，回归平方差，剩余平方差
// rows：数据行数；
// cols数据列数；
// 返回：0求解成功，-1错误
void Display(double *dat, double *Answer, double *SquarePoor, int rows, int cols)
{
	double v, *p;
	int i, j;
	printf("回归方程式:    Y = %.5lf", Answer[0]);
	for (i = 1; i < cols; i++)
		printf(" + %.5lf*X%d", Answer[i], i);
	printf(" \n");
	printf("回归显著性检验:  \n");
	printf("回归平方和：%12.4lf  回归方差：%12.4lf  \n", SquarePoor[0], SquarePoor[2]);
	printf("剩余平方和：%12.4lf  剩余方差：%12.4lf  \n", SquarePoor[1], SquarePoor[3]);
	printf("离差平方和：%12.4lf  标准误差：%12.4lf  \n", SquarePoor[0] + SquarePoor[1], sqrt(SquarePoor[3]));
	printf("F   检  验：%12.4lf  相关系数：%12.4lf  \n", SquarePoor[2] / SquarePoor[3],
		sqrt(SquarePoor[0] / (SquarePoor[0] + SquarePoor[1])));
	printf("剩余分析:  \n");
	printf("      观察值      估计值      剩余值    剩余平方  \n");
	for (i = 0, p = dat; i < rows; i++, p++)
	{
		v = Answer[0];
		for (j = 1; j < cols; j++, p++)
			v += *p * Answer[j];
		printf("%12.2lf%12.2lf%12.2lf%12.2lf  \n", *p, v, *p - v, (*p - v) * (*p - v));
	}
	//system("pause");
	printf(" \n");
}

// 功能：显示计算结果，只显示回归系数
// dat：二维数组，X1、X2……Y的矩阵；
// Answer[cols]：输入回归系数数组(B0,B1...Bn)
// rows：数据行数；
// cols数据列数；
// 返回：0求解成功，-1错误
void DisplayOnlyB(double *dat, double *Answer, int rows, int cols)
{
	double v, *p;
	int i, j;
	printf("回归方程:Y = %.5lf", Answer[0]);
	for (i = 1; i < cols; i++)
		printf(" + %.5lf*X%d", Answer[i], i);
	printf(" \n");
	printf("数据对比:  \n");
	printf("      观察值      估计值  \n");
	for (i = 0, p = dat; i < rows; i++, p++)
	{
		v = Answer[0];
		for (j = 1; j < cols; j++, p++)
			v += *p * Answer[j];
		printf("%12.2lf%12.2lf  \n", *p, v);
	}
	//system("pause");
}

// 功能：输出回归方程系数
// data：二维数组，X1、X2……Y的矩阵；
// rows：数据行数；
// cols数据列数；
// Answer[cols]：输入回归系数数组(B0,B1...Bn)
// 返回：0求解成功，-1错误
int PrintCoefficient(double *data, int rows, int cols, double *Answer)
{
	if (MultipleRegressionOnlyB((double*)data, rows, cols, Answer) == 0)
	{
		int i;
		printf("回归方程:");
		printf("Y = %.5lf", Answer[0]);
		for (i = 1; i < cols; i++)
		{
			printf(" + %.5lf*X%d", Answer[i], i);
		}
		printf(" \n");
		return 0;
	}
	else  return -1;
}

/*
 * 线性回归Qt接口
 * 输出: 字符串结果
 */
QString QLinearRegression(QString FileName, QString &strOutCsv)
{
	QString strOut; // 输出

					// 【1】用C语言版本算-效果还好
					// 载入文件
	QList<QList<double>> matInput = JIO::readMat(FileName);
	int matRow = matInput.size();
	int matCol = 0;
	if (matRow > 0)
		matCol = matInput[0].size();
	// 多元线性回归
	double *data = new double[matRow * matCol];
	double *Answer = new double[matCol];

	for (int i = 0; i < matRow; ++i)
	{
		for (int j = 0; j < matCol; ++j)
		{
			data[i*matCol + j] = matInput[i][j];
		}
	}

	if (MultipleRegressionOnlyB(data, matRow, matCol, Answer) == 0)
	{
		int i;
		int cols = matCol;
		strOut.sprintf("Y = %.5lf", Answer[0]);
		strOutCsv.sprintf("%.5lf,", Answer[0]);
		for (i = 1; i < cols; i++)
		{
			QString temp;
			QString tempCsv;
			temp.sprintf(" + %.5lf*X%d", Answer[i], i);
			tempCsv.sprintf("%.5lf,", Answer[i]);
			strOut += temp;
			strOutCsv += tempCsv;
		}
		strOutCsv = strOutCsv.left(strOutCsv.lastIndexOf(','));
	}

	delete[] data;
	delete[] Answer;

	// 【2】用mat来算的例子(与matlab计算结果相差大，不好)
	//	QList<QList<double>> inMat = JIO::MatToDList(FileName);
	//	mat X(inMat.size(),inMat[0].size());
	//	X.fill(1);
	//	for(int i = 0; i<inMat.size(); ++i)
	//	{
	//		for(int j = 0; j<inMat[0].size()-1; ++j)
	//		{
	//			X(i,j+1) = inMat[i][j];
	//		}
	//	}
	// //	X.save("X.csv", raw_ascii);
	//	mat Y(inMat.size(),1);
	//	int &&ycol = inMat[0].size()-1;
	//	for(int i=0; i<inMat.size(); ++i)
	//	{
	//		Y(i,0) = inMat[i][ycol];
	//	}
	// //	Y.save("Y.csv", raw_ascii);
	//	//b = (X'X)^(-1)X'Y 核心公式
	//	mat B = inv(X.t()*X)*X.t()*Y;
	// //	B.save("B.csv", raw_ascii);

	//	// 保存字符串
	//	int i;
	//	int rows = B.n_rows;
	//	strOut.sprintf("Y = %.5lf", B(0,0));
	//	strOutCsv.sprintf("%.15lf,", B(0,0));
	//	for (i = 1; i < rows; i++)
	//	{
	//		QString temp;
	//		QString tempCsv;
	//		temp.sprintf(" + %.5lf*X%d", B(i,0), i);
	//		tempCsv.sprintf("%.15lf,", B(i,0));
	//		strOut += temp;
	//		strOutCsv += tempCsv;
	//	}
	//	strOutCsv = strOutCsv.left(strOutCsv.lastIndexOf(','));

	return strOut;
}


/*
* 线性回归Qt接口
* 输出: 回归数组
*/
QList<double> QLinearRegression(QString FileName)
{
	// 输出
	QList<double> OutList;
	// 载入文件
	QList<QList<double>> matInput = JIO::readMat(FileName);
	int matRow = matInput.size();
	int matCol = 0;
	if (matRow > 0)
		matCol = matInput[0].size();
	// 多元线性回归
	double* data = new double[matRow * matCol];
	double* Answer = new double[matCol];
	for (int i = 0; i < matRow; ++i)
	{
		for (int j = 0; j < matCol; ++j)
		{
			data[i * matCol + j] = matInput[i][j];
		}
	}
	QString strOut;
	if (MultipleRegressionOnlyB(data, matRow, matCol, Answer) == 0)
	{
		int i;
		int cols = matCol;
		strOut.sprintf("Y = %.5lf", Answer[0]);
		OutList.append(Answer[0]);
		for (i = 1; i < cols; i++)
		{
			QString temp;
			temp.sprintf(" + %.5lf*X%d", Answer[i], i);
			OutList.append(Answer[i]);
			strOut += temp;
		}
	}

	delete[] data;
	delete[] Answer;

	qDebug() << strOut;
	return OutList;
}

/*
* 线性回归Qt接口
* 输入: 二维QList
* 输出: 回归数组
*/
QList<double> QLinearRegression(QList<QList<double>> matInput)
{
	// 输出
	QList<double> OutList;
	// 载入文件
	int matRow = matInput.size();
	int matCol = 0;
	if (matRow > 0)
		matCol = matInput[0].size();
	// 多元线性回归
	double* data = new double[matRow * matCol];
	double* Answer = new double[matCol];
	for (int i = 0; i < matRow; ++i)
	{
		for (int j = 0; j < matCol; ++j)
		{
			data[i * matCol + j] = matInput[i][j];
		}
	}
	QString strOut;
	if (MultipleRegressionOnlyB(data, matRow, matCol, Answer) == 0)
	{
		int i;
		int cols = matCol;
		strOut.sprintf("Y = %.5lf", Answer[0]);
		OutList.append(Answer[0]);
		for (i = 1; i < cols; i++)
		{
			QString temp;
			temp.sprintf(" + %.5lf*X%d", Answer[i], i);
			OutList.append(Answer[i]);
			strOut += temp;
		}
	}

	delete[] data;
	delete[] Answer;

	qDebug() << strOut;
	return OutList;
}

/********************2、【数据标准化相关函数】********************/

/* 定死的数据 */
// FBG标定时所用波长-应力
vector<double> standWave01 = { 1536,1538,1540,1542,1544,1546,1547,1550,1552,1554,1555,1558,1560,1561,1564 };
vector<double> standWave02 = { 1550,1552,1554,1556,1559,1560,1562,1563 };
vector<double> standWave03 = { 1536,1538,1540,1542,1544,1546,1548,1550,1552,1554,1556,1558,1560,1562,1564 };
vector<double> standWave04 = { 1536,1538,1540,1542,1544,1546,1548,1550,1552,1554,1556,1558,1560,1562,1564 };
vector<double> standWave05 = { 1536,1538,1540,1542,1544,1546,1548,1551,1552,1554,1556,1558,1560,1562,1564 };
vector<double> standWave06 = { 1536,1538,1540,1542,1544,1546,1548,1550,1552,1554,1556,1558,1560,1562,1563 };
vector<double> standWave07 = { 1536,1538,1540,1542,1544,1546,1548 };
// FBG标定时所用波长-温度
vector<double> standWave08 = { 1535.812,1537.794,1539.784,1541.831,1543.769,1545.771,1547.778,1549.832,1551.942,1553.969,1555.9,1557.744,1559.768,1561.9,1563.821 };
vector<double> standWave09 = { 1549.8,1551.835,1553.913,1555.955,1557.982,1559.878,1561.884,1563.831 };
vector<double> standWave10 = { 1551.819,1553.809,1555.166,1557.806,1559.772,1561.839,1563.772 };
vector<double> standWave11 = { 1535.818,1537.85,1539.836,1541.884,1543.833,1545.827,1547.818,1549.816,1551.777,1553.801,1555.885,1557.881,1559.842,1561.78,1563.736 };
vector<double> standWave12 = { 1535.781,1537.786,1539.775,1541.843,1543.813,1545.788,1547.763,1549.777,1551.792,1553.774,1555.843,1557.841,1559.891,1561.979,1563.997 };
vector<double> standWave13 = { 1535.787,1537.795,1539.778,1541.81,1543.792,1545.748,1547.752,1549.752,1551.824,1553.802,1555.194,1557.897,1559.834,1561.887,1563.856 };
vector<double> standWave14 = { 1535.818,1537.837,1539.827,1541.867,1543.772,1545.768,1547.764 };
vector<double> standWave15 = { 1535.855,1537.92,1539.875,1541.905,1543.903,1545.854,1547.871,1549.908 };
vector<double> standWave16 = { 1537.823,1540.893,1543.839,1546.791,1549.891,1552.751,1556.796,1559.775 };
vector<double> standWave17 = { 1537.799,1540.777,1543.827,1546.784,1549.774,1552.761,1556.747,1559.754 };
vector<double> standWave18 = { 1537.795,1540.782,1543.807,1546.745,1550.039,1552.808,1556.796,1559.78 };
vector<double> standWave19 = { 1536.79,1539.759,1542.691,1545.759,1548.719,1551.835,1554.707,1557.714,1560.756,1563.697 };
vector<double> standWave20 = { 1537.828,1540.804,1543.726,1546.769,1549.698,1552.749,1555.862,1558.796,1561.737,1565.76 };
vector<double> standWave21 = { 1533.177,1536.68,1539.622,1542.445,1545.646,1548.485,1551.763 };
vector<double> standWave22 = { 1533.139,1536.207,1539.487,1542.141,1545.127,1548.153,1551.433,1554.22,1557.324,1560.406 };
vector<double> standWave23 = { 1532.322,1535.331,1538.348,1541.278 };
vector<double> standWave24 = { 1532.238,1535.493,1538.507,1541.482,1544.521,1547.337,1550.38,1553.582,1556.3,1559.4 };
vector<double> standWave25 = { 1533.363,1536.476,1538.212,1541.983,1544.813,1548.062,1550.77,1554.162,1556.829,1559.949 };
vector<double> standWave26 = { 1547.437,1553.448,1556.468,1559.291 };
vector<double> standWave27 = { 1537.852,1540.774,1543.699,1546.773,1549.698,1552.776,1555.862,1558.742,1561.839 };
vector<double> standWave28 = { 1536.781,1539.743,1542.735,1545.769,1548.737,1551.88,1554.742,1557.776,1560.722,1563.742 };
vector<double> standWave29 = { 1537.861,1540.801,1543.742,1546.799,1549.847,1552.743,1555.881,1558.777,1561.789,1565.814 };
vector<double> standWave30 = { 1536.815,1539.839,1542.709,1545.738,1548.851,1551.866,1554.714,1557.736,1560.76,1563.732 };
vector<double> standWave31 = { 1537.796,1540.815,1543.709,1546.75,1549.719,1552.755,1555.831,1558.739,1561.774,1565.756 };
vector<double> standWave32 = { 1554.925,1558.128,1561.035 };

// FBG标定波长+标定温度
double WaveAndTemp[231][2] = { { 9.3,1535.91 },{ 9.3,1537.892 },{ 9.1,1539.88 },{ 9.2,1541.928 },{ 9.1,1543.865 },{ 9,1545.865 },{ 8.9,1547.871 },{ 8.9,1549.925 },{ 8.4,1552.03 },{ 8.5,1554.058 },{ 8.7,1555.991 },{ 8.7,1557.835 },{ 8.6,1559.858 },{ 8.5,1561.989 },{ 8.5,1563.91 },{ 8.4,1549.888 },{ 8.4,1551.923 },{ 8.6,1554.003 },{ 8.7,1556.046 },{ 8.6,1558.072 },{ 8.6,1559.968 },{ 8.5,1561.973 },{ 8.6,1563.921 },{ 8.5,1551.908 },{ 8.6,1553.899 },{ 8.6,1555.256 },{ 8.7,1557.897 },{ 8.6,1559.862 },{ 8.6,1561.929 },{ 8.7,1563.863 },{ 9.6,1535.919 },{ 9.7,1537.952 },{ 9.6,1539.937 },{ 9.7,1541.986 },{ 9.6,1543.934 },{ 9.5,1545.927 },{ 9.4,1547.917 },{ 9.4,1549.915 },{ 8.6,1551.867 },{ 8.8,1553.893 },{ 8.7,1555.976 },{ 8.5,1557.97 },{ 8.4,1559.93 },{ 8.4,1561.868 },{ 8.4,1563.824 },{ 9.7,1535.883 },{ 9.6,1537.887 },{ 9.6,1539.876 },{ 9.6,1541.944 },{ 9.8,1543.916 },{ 9.4,1545.887 },{ 9.4,1547.862 },{ 9.3,1549.875 },{ 8.6,1551.882 },{ 8.6,1553.864 },{ 8.6,1555.933 },{ 8.4,1557.929 },{ 8.4,1559.979 },{ 8.4,1562.067 },{ 8.5,1564.086 },{ 9.5,1535.887 },{ 9.5,1537.895 },{ 9.5,1539.878 },{ 9.4,1541.909 },{ 9.4,1543.891 },{ 9.3,1545.846 },{ 9.3,1547.85 },{ 9.2,1549.849 },{ 8.5,1551.913 },{ 8.4,1553.89 },{ 8.5,1555.283 },{ 8.5,1557.986 },{ 8.4,1559.922 },{ 8.3,1561.974 },{ 8.4,1563.944 },{ 9.4,1535.917 },{ 9.4,1537.936 },{ 9.2,1539.924 },{ 9.2,1541.964 },{ 9.2,1543.869 },{ 9.1,1545.864 },{ 9.1,1547.86 },{ 9.3,1535.953 },{ 9.3,1538.018 },{ 9.2,1539.972 },{ 9.3,1542.003 },{ 9.3,1544.001 },{ 9.3,1545.952 },{ 9.2,1547.968 },{ 9.1,1550.004 },{ 8.9,1537.916 },{ 9.1,1540.989 },{ 9,1543.933 },{ 8.9,1546.884 },{ 8.8,1549.983 },{ 8.7,1552.842 },{ 8.6,1556.886 },{ 8.7,1559.866 },{ 8.8,1537.891 },{ 8.7,1540.868 },{ 8.8,1543.919 },{ 8.6,1546.874 },{ 8.7,1549.865 },{ 8.7,1552.852 },{ 8.7,1556.838 },{ 8.7,1559.845 },{ 8.1,1537.88 },{ 8.1,1540.867 },{ 8.4,1543.895 },{ 8.5,1546.834 },{ 8.6,1550.129 },{ 8.6,1552.898 },{ 8.7,1556.887 },{ 8.6,1559.87 },{ 8.6,1536.88 },{ 8.8,1539.851 },{ 8.8,1542.783 },{ 8.7,1545.85 },{ 8.7,1548.81 },{ 8.6,1551.925 },{ 8.9,1554.8 },{ 8.8,1557.806 },{ 8.7,1560.847 },{ 8.7,1563.788 },{ 9.4,1537.927 },{ 9.1,1540.9 },{ 9.3,1543.824 },{ 9.4,1546.868 },{ 9.2,1549.795 },{ 9.4,1552.848 },{ 9.2,1555.959 },{ 9.2,1558.893 },{ 9.1,1561.833 },{ 9.2,1565.857 },{ 9.8,1533.28 },{ 9.7,1536.782 },{ 9.7,1539.724 },{ 9.4,1542.544 },{ 9.5,1545.746 },{ 9.3,1548.583 },{ 9.4,1551.862 },{ 8.8,1533.231 },{ 8.9,1536.3 },{ 8.8,1539.579 },{ 8.9,1542.234 },{ 9.2,1545.224 },{ 9.2,1548.25 },{ 9.1,1551.529 },{ 9.1,1554.316 },{ 9.5,1557.424 },{ 9.6,1560.507 },{ 9.2,1532.419 },{ 8.8,1535.423 },{ 8.8,1538.44 },{ 8.8,1541.37 },{ 9.5,1532.338 },{ 9.5,1535.593 },{ 9.4,1538.606 },{ 9.2,1541.579 },{ 9.4,1544.62 },{ 9.4,1547.436 },{ 9.5,1550.48 },{ 9.3,1553.68 },{ 9.6,1556.401 },{ 9.5,1559.5 },{ 9.7,1533.465 },{ 9.5,1536.576 },{ 9.4,1538.311 },{ 9.3,1542.081 },{ 9.5,1544.913 },{ 9.2,1548.159 },{ 9.3,1550.868 },{ 9.3,1554.26 },{ 9.4,1556.928 },{ 9.3,1560.047 },{ 9.5,1547.537 },{ 9.4,1553.547 },{ 9.5,1556.568 },{ 9.4,1559.39 },{ 8,1537.936 },{ 7.9,1540.857 },{ 8.1,1543.784 },{ 8.2,1546.859 },{ 8.3,1549.785 },{ 8.2,1552.862 },{ 8.1,1555.947 },{ 8.1,1558.827 },{ 8,1561.923 },{ 8.3,1536.868 },{ 8.5,1539.832 },{ 8.7,1542.826 },{ 8.7,1545.86 },{ 8.8,1548.829 },{ 8.8,1551.972 },{ 8.9,1554.835 },{ 8.9,1557.869 },{ 8.9,1560.815 },{ 8.9,1563.835 },{ 7.9,1537.944 },{ 8,1540.885 },{ 7.9,1543.825 },{ 8,1546.883 },{ 8,1549.931 },{ 8,1552.827 },{ 8,1555.965 },{ 8.1,1558.862 },{ 8,1561.873 },{ 8,1565.898 },{ 8.2,1536.901 },{ 8.3,1539.926 },{ 8.4,1542.797 },{ 8.6,1545.828 },{ 8.7,1548.942 },{ 8.7,1551.957 },{ 8.7,1554.805 },{ 8.5,1557.825 },{ 8.4,1560.848 },{ 8.4,1563.82 },{ 8,1537.88 },{ 8.1,1540.9 },{ 8.2,1543.795 },{ 8.2,1546.836 },{ 8.2,1549.805 },{ 8.3,1552.842 },{ 8.4,1555.919 },{ 8.5,1558.828 },{ 8.6,1561.864 },{ 8.5,1565.845 },{ 8.876,1555.018 },{ 8.576,1558.218 },{ 8.676,1561.126 } };

// 各数据项名
QString DataName_DS18B20 = "CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH07-01,CH07-02,CH07-03,CH07-04";
QString DataName_DS18ALL = "CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH07-01,CH07-02,CH07-03,CH07-04,CH07-05,CH07-06,CH07-07,CH07-08,CH08-01,CH08-02,CH08-03,CH08-04,CH08-05,CH08-06,CH08-07,CH08-08";
QString DataName_FBGT = "CH08-01,CH08-02,CH08-03,CH08-04,CH08-05,CH08-06,CH08-07,CH08-08,CH08-09,CH08-10,CH08-11,CH08-12,CH08-13,CH08-14,CH08-15,CH09-01,CH09-02,CH09-03,CH09-04,CH09-05,CH09-06,CH09-07,CH09-08,CH10-01,CH10-02,CH10-03,CH10-04,CH10-05,CH10-06,CH10-07,CH11-01,CH11-02,CH11-03,CH11-04,CH11-05,CH11-06,CH11-07,CH11-08,CH11-09,CH11-10,CH11-11,CH11-12,CH11-13,CH11-14,CH11-15,CH12-01,CH12-02,CH12-03,CH12-04,CH12-05,CH12-06,CH12-07,CH12-08,CH12-09,CH12-10,CH12-11,CH12-12,CH12-13,CH12-14,CH12-15,CH13-01,CH13-02,CH13-03,CH13-04,CH13-05,CH13-06,CH13-07,CH13-08,CH13-09,CH13-10,CH13-11,CH13-12,CH13-13,CH13-14,CH13-15,CH14-01,CH14-02,CH14-03,CH14-04,CH14-05,CH14-06,CH14-07,CH15-01,CH15-02,CH15-03,CH15-04,CH15-05,CH15-06,CH15-07,CH15-08,CH16-01,CH16-02,CH16-03,CH16-04,CH16-05,CH16-06,CH16-07,CH16-08,CH17-01,CH17-02,CH17-03,CH17-04,CH17-05,CH17-06,CH17-07,CH17-08,CH18-01,CH18-02,CH18-03,CH18-04,CH18-05,CH18-06,CH18-07,CH18-08,CH19-01,CH19-02,CH19-03,CH19-04,CH19-05,CH19-06,CH19-07,CH19-08,CH19-09,CH19-10,CH20-01,CH20-02,CH20-03,CH20-04,CH20-05,CH20-06,CH20-07,CH20-08,CH20-09,CH20-10,CH21-01,CH21-02,CH21-03,CH21-04,CH21-05,CH21-06,CH21-07,CH22-01,CH22-02,CH22-03,CH22-04,CH22-05,CH22-06,CH22-07,CH22-08,CH22-09,CH22-10,CH23-01,CH23-02,CH23-03,CH23-04,CH24-01,CH24-02,CH24-03,CH24-04,CH24-05,CH24-06,CH24-07,CH24-08,CH24-09,CH24-10,CH25-01,CH25-02,CH25-03,CH25-04,CH25-05,CH25-06,CH25-07,CH25-08,CH25-09,CH25-10,CH26-01,CH26-02,CH26-03,CH26-04,CH27-01,CH27-02,CH27-03,CH27-04,CH27-05,CH27-06,CH27-07,CH27-08,CH27-09,CH28-01,CH28-02,CH28-03,CH28-04,CH28-05,CH28-06,CH28-07,CH28-08,CH28-09,CH28-10,CH29-01,CH29-02,CH29-03,CH29-04,CH29-05,CH29-06,CH29-07,CH29-08,CH29-09,CH29-10,CH30-01,CH30-02,CH30-03,CH30-04,CH30-05,CH30-06,CH30-07,CH30-08,CH30-09,CH30-10,CH31-01,CH31-02,CH31-03,CH31-04,CH31-05,CH31-06,CH31-07,CH31-08,CH31-09,CH31-10,CH32-01,CH32-02,CH32-03";
QString DataName_FBGS = "CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH01-09,CH01-10,CH01-11,CH01-12,CH01-13,CH01-14,CH01-15,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH03-09,CH03-10,CH03-11,CH03-12,CH03-13,CH03-14,CH03-15,CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH04-09,CH04-10,CH04-11,CH04-12,CH04-13,CH04-14,CH04-15,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH05-09,CH05-10,CH05-11,CH05-12,CH05-13,CH05-14,CH05-15,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH06-09,CH06-10,CH06-11,CH06-12,CH06-13,CH06-14,CH06-15,CH07-01,CH07-02,CH07-03,CH07-04,CH07-05,CH07-06,CH07-07";
// 所有FBG通道（全部1-32通道的1-20）
QString DataName_FBG = "CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH01-09,CH01-10,CH01-11,CH01-12,CH01-13,CH01-14,CH01-15,CH01-16,CH01-17,CH01-18,CH01-19,CH01-20,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH02-09,CH02-10,CH02-11,CH02-12,CH02-13,CH02-14,CH02-15,CH02-16,CH02-17,CH02-18,CH02-19,CH02-20,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH03-09,CH03-10,CH03-11,CH03-12,CH03-13,CH03-14,CH03-15,CH03-16,CH03-17,CH03-18,CH03-19,CH03-20,CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH04-09,CH04-10,CH04-11,CH04-12,CH04-13,CH04-14,CH04-15,CH04-16,CH04-17,CH04-18,CH04-19,CH04-20,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH05-09,CH05-10,CH05-11,CH05-12,CH05-13,CH05-14,CH05-15,CH05-16,CH05-17,CH05-18,CH05-19,CH05-20,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH06-09,CH06-10,CH06-11,CH06-12,CH06-13,CH06-14,CH06-15,CH06-16,CH06-17,CH06-18,CH06-19,CH06-20,CH07-01,CH07-02,CH07-03,CH07-04,CH07-05,CH07-06,CH07-07,CH07-08,CH07-09,CH07-10,CH07-11,CH07-12,CH07-13,CH07-14,CH07-15,CH07-16,CH07-17,CH07-18,CH07-19,CH07-20,CH08-01,CH08-02,CH08-03,CH08-04,CH08-05,CH08-06,CH08-07,CH08-08,CH08-09,CH08-10,CH08-11,CH08-12,CH08-13,CH08-14,CH08-15,CH08-16,CH08-17,CH08-18,CH08-19,CH08-20,CH09-01,CH09-02,CH09-03,CH09-04,CH09-05,CH09-06,CH09-07,CH09-08,CH09-09,CH09-10,CH09-11,CH09-12,CH09-13,CH09-14,CH09-15,CH09-16,CH09-17,CH09-18,CH09-19,CH09-20,CH10-01,CH10-02,CH10-03,CH10-04,CH10-05,CH10-06,CH10-07,CH10-08,CH10-09,CH10-10,CH10-11,CH10-12,CH10-13,CH10-14,CH10-15,CH10-16,CH10-17,CH10-18,CH10-19,CH10-20,CH11-01,CH11-02,CH11-03,CH11-04,CH11-05,CH11-06,CH11-07,CH11-08,CH11-09,CH11-10,CH11-11,CH11-12,CH11-13,CH11-14,CH11-15,CH11-16,CH11-17,CH11-18,CH11-19,CH11-20,CH12-01,CH12-02,CH12-03,CH12-04,CH12-05,CH12-06,CH12-07,CH12-08,CH12-09,CH12-10,CH12-11,CH12-12,CH12-13,CH12-14,CH12-15,CH12-16,CH12-17,CH12-18,CH12-19,CH12-20,CH13-01,CH13-02,CH13-03,CH13-04,CH13-05,CH13-06,CH13-07,CH13-08,CH13-09,CH13-10,CH13-11,CH13-12,CH13-13,CH13-14,CH13-15,CH13-16,CH13-17,CH13-18,CH13-19,CH13-20,CH14-01,CH14-02,CH14-03,CH14-04,CH14-05,CH14-06,CH14-07,CH14-08,CH14-09,CH14-10,CH14-11,CH14-12,CH14-13,CH14-14,CH14-15,CH14-16,CH14-17,CH14-18,CH14-19,CH14-20,CH15-01,CH15-02,CH15-03,CH15-04,CH15-05,CH15-06,CH15-07,CH15-08,CH15-09,CH15-10,CH15-11,CH15-12,CH15-13,CH15-14,CH15-15,CH15-16,CH15-17,CH15-18,CH15-19,CH15-20,CH16-01,CH16-02,CH16-03,CH16-04,CH16-05,CH16-06,CH16-07,CH16-08,CH16-09,CH16-10,CH16-11,CH16-12,CH16-13,CH16-14,CH16-15,CH16-16,CH16-17,CH16-18,CH16-19,CH16-20,CH17-01,CH17-02,CH17-03,CH17-04,CH17-05,CH17-06,CH17-07,CH17-08,CH17-09,CH17-10,CH17-11,CH17-12,CH17-13,CH17-14,CH17-15,CH17-16,CH17-17,CH17-18,CH17-19,CH17-20,CH18-01,CH18-02,CH18-03,CH18-04,CH18-05,CH18-06,CH18-07,CH18-08,CH18-09,CH18-10,CH18-11,CH18-12,CH18-13,CH18-14,CH18-15,CH18-16,CH18-17,CH18-18,CH18-19,CH18-20,CH19-01,CH19-02,CH19-03,CH19-04,CH19-05,CH19-06,CH19-07,CH19-08,CH19-09,CH19-10,CH19-11,CH19-12,CH19-13,CH19-14,CH19-15,CH19-16,CH19-17,CH19-18,CH19-19,CH19-20,CH20-01,CH20-02,CH20-03,CH20-04,CH20-05,CH20-06,CH20-07,CH20-08,CH20-09,CH20-10,CH20-11,CH20-12,CH20-13,CH20-14,CH20-15,CH20-16,CH20-17,CH20-18,CH20-19,CH20-20,CH21-01,CH21-02,CH21-03,CH21-04,CH21-05,CH21-06,CH21-07,CH21-08,CH21-09,CH21-10,CH21-11,CH21-12,CH21-13,CH21-14,CH21-15,CH21-16,CH21-17,CH21-18,CH21-19,CH21-20,CH22-01,CH22-02,CH22-03,CH22-04,CH22-05,CH22-06,CH22-07,CH22-08,CH22-09,CH22-10,CH22-11,CH22-12,CH22-13,CH22-14,CH22-15,CH22-16,CH22-17,CH22-18,CH22-19,CH22-20,CH23-01,CH23-02,CH23-03,CH23-04,CH23-05,CH23-06,CH23-07,CH23-08,CH23-09,CH23-10,CH23-11,CH23-12,CH23-13,CH23-14,CH23-15,CH23-16,CH23-17,CH23-18,CH23-19,CH23-20,CH24-01,CH24-02,CH24-03,CH24-04,CH24-05,CH24-06,CH24-07,CH24-08,CH24-09,CH24-10,CH24-11,CH24-12,CH24-13,CH24-14,CH24-15,CH24-16,CH24-17,CH24-18,CH24-19,CH24-20,CH25-01,CH25-02,CH25-03,CH25-04,CH25-05,CH25-06,CH25-07,CH25-08,CH25-09,CH25-10,CH25-11,CH25-12,CH25-13,CH25-14,CH25-15,CH25-16,CH25-17,CH25-18,CH25-19,CH25-20,CH26-01,CH26-02,CH26-03,CH26-04,CH26-05,CH26-06,CH26-07,CH26-08,CH26-09,CH26-10,CH26-11,CH26-12,CH26-13,CH26-14,CH26-15,CH26-16,CH26-17,CH26-18,CH26-19,CH26-20,CH27-01,CH27-02,CH27-03,CH27-04,CH27-05,CH27-06,CH27-07,CH27-08,CH27-09,CH27-10,CH27-11,CH27-12,CH27-13,CH27-14,CH27-15,CH27-16,CH27-17,CH27-18,CH27-19,CH27-20,CH28-01,CH28-02,CH28-03,CH28-04,CH28-05,CH28-06,CH28-07,CH28-08,CH28-09,CH28-10,CH28-11,CH28-12,CH28-13,CH28-14,CH28-15,CH28-16,CH28-17,CH28-18,CH28-19,CH28-20,CH29-01,CH29-02,CH29-03,CH29-04,CH29-05,CH29-06,CH29-07,CH29-08,CH29-09,CH29-10,CH29-11,CH29-12,CH29-13,CH29-14,CH29-15,CH29-16,CH29-17,CH29-18,CH29-19,CH29-20,CH30-01,CH30-02,CH30-03,CH30-04,CH30-05,CH30-06,CH30-07,CH30-08,CH30-09,CH30-10,CH30-11,CH30-12,CH30-13,CH30-14,CH30-15,CH30-16,CH30-17,CH30-18,CH30-19,CH30-20,CH31-01,CH31-02,CH31-03,CH31-04,CH31-05,CH31-06,CH31-07,CH31-08,CH31-09,CH31-10,CH31-11,CH31-12,CH31-13,CH31-14,CH31-15,CH31-16,CH31-17,CH31-18,CH31-19,CH31-20,CH32-01,CH32-02,CH32-03,CH32-04,CH32-05,CH32-06,CH32-07,CH32-08,CH32-09,CH32-10,CH32-11,CH32-12,CH32-13,CH32-14,CH32-15,CH32-16,CH32-17,CH32-18,CH32-19,CH32-20";
QString DataName_CCD = "X,Y,Z";
QString DataName_ENV = "Back,Right,Left,Front";
QString DataName_CNC = "CH,XPOS,YPOS,ZPOS,MAPOS,FR,SP,XPWR,YPWR,ZPWR,MAPWR,XFU,YFU,ZFU,MAFU,PA";
// 所有FBG通道（有用的231个温度）
QString DataName_FBGST = "CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH01-09,CH01-10,CH01-11,CH01-12,CH01-13,CH01-14,CH01-15,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH03-09,CH03-10,CH03-11,CH03-12,CH03-13,CH03-14,CH03-15,CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH04-09,CH04-10,CH04-11,CH04-12,CH04-13,CH04-14,CH04-15,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH05-09,CH05-10,CH05-11,CH05-12,CH05-13,CH05-14,CH05-15,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH06-09,CH06-10,CH06-11,CH06-12,CH06-13,CH06-14,CH06-15,CH07-01,CH07-02,CH07-03,CH07-04,CH07-05,CH07-06,CH07-07,CH08-01,CH08-02,CH08-03,CH08-04,CH08-05,CH08-06,CH08-07,CH08-08,CH08-09,CH08-10,CH08-11,CH08-12,CH08-13,CH08-14,CH08-15,CH09-01,CH09-02,CH09-03,CH09-04,CH09-05,CH09-06,CH09-07,CH09-08,CH10-01,CH10-02,CH10-03,CH10-04,CH10-05,CH10-06,CH10-07,CH11-01,CH11-02,CH11-03,CH11-04,CH11-05,CH11-06,CH11-07,CH11-08,CH11-09,CH11-10,CH11-11,CH11-12,CH11-13,CH11-14,CH11-15,CH12-01,CH12-02,CH12-03,CH12-04,CH12-05,CH12-06,CH12-07,CH12-08,CH12-09,CH12-10,CH12-11,CH12-12,CH12-13,CH12-14,CH12-15,CH13-01,CH13-02,CH13-03,CH13-04,CH13-05,CH13-06,CH13-07,CH13-08,CH13-09,CH13-10,CH13-11,CH13-12,CH13-13,CH13-14,CH13-15,CH14-01,CH14-02,CH14-03,CH14-04,CH14-05,CH14-06,CH14-07,CH15-01,CH15-02,CH15-03,CH15-04,CH15-05,CH15-06,CH15-07,CH15-08,CH16-01,CH16-02,CH16-03,CH16-04,CH16-05,CH16-06,CH16-07,CH16-08,CH17-01,CH17-02,CH17-03,CH17-04,CH17-05,CH17-06,CH17-07,CH17-08,CH18-01,CH18-02,CH18-03,CH18-04,CH18-05,CH18-06,CH18-07,CH18-08,CH19-01,CH19-02,CH19-03,CH19-04,CH19-05,CH19-06,CH19-07,CH19-08,CH19-09,CH19-10,CH20-01,CH20-02,CH20-03,CH20-04,CH20-05,CH20-06,CH20-07,CH20-08,CH20-09,CH20-10,CH21-01,CH21-02,CH21-03,CH21-04,CH21-05,CH21-06,CH21-07,CH22-01,CH22-02,CH22-03,CH22-04,CH22-05,CH22-06,CH22-07,CH22-08,CH22-09,CH22-10,CH23-01,CH23-02,CH23-03,CH23-04,CH24-01,CH24-02,CH24-03,CH24-04,CH24-05,CH24-06,CH24-07,CH24-08,CH24-09,CH24-10,CH25-01,CH25-02,CH25-03,CH25-04,CH25-05,CH25-06,CH25-07,CH25-08,CH25-09,CH25-10,CH26-01,CH26-02,CH26-03,CH26-04,CH27-01,CH27-02,CH27-03,CH27-04,CH27-05,CH27-06,CH27-07,CH27-08,CH27-09,CH28-01,CH28-02,CH28-03,CH28-04,CH28-05,CH28-06,CH28-07,CH28-08,CH28-09,CH28-10,CH29-01,CH29-02,CH29-03,CH29-04,CH29-05,CH29-06,CH29-07,CH29-08,CH29-09,CH29-10,CH30-01,CH30-02,CH30-03,CH30-04,CH30-05,CH30-06,CH30-07,CH30-08,CH30-09,CH30-10,CH31-01,CH31-02,CH31-03,CH31-04,CH31-05,CH31-06,CH31-07,CH31-08,CH31-09,CH31-10,CH32-01,CH32-02,CH32-03";

// 【2017-06-1之后换了16 17 18通道，换了4个的】

//vector<double> standWave16_New170601 = {1557.858,1559.846,1561.851,1563.835};
vector<double> standWave16_New170601 = { 1541.799899,1557.854899,1559.842899,1561.890899 };
vector<double> standWave17_New170601 = { 1550.802,1552.831,1554.897,1556.897 };
vector<double> standWave18_New170601 = { 1543.804,1545.869,1547.865,1549.805 };
// FBG标定波长(0度时) 适用于2017-06-1之后
// 陈学长标定
//const double calibrationWave[231] = {1535.812, 1537.794, 1539.784, 1541.831, 1543.769, 1545.771, 1547.778, 1549.832, 1551.942, 1553.969, 1555.9, 1557.744, 1559.768, 1561.9, 1563.821, 1549.8, 1551.835, 1553.913, 1555.955, 1557.982, 1559.878, 1561.884, 1563.831, 1551.819, 1553.809, 1555.166, 1557.806, 1559.772, 1561.839, 1563.772, 1535.818, 1537.85, 1539.836, 1541.884, 1543.833, 1545.827, 1547.818, 1549.816, 1551.777, 1553.801, 1555.885, 1557.881, 1559.842, 1561.78, 1563.736, 1535.781, 1537.786, 1539.775, 1541.843, 1543.813, 1545.788, 1547.763, 1549.777, 1551.792, 1553.774, 1555.843, 1557.841, 1559.891, 1561.979, 1563.997, 1535.787, 1537.795, 1539.778, 1541.81, 1543.792, 1545.748, 1547.752, 1549.752, 1551.824, 1553.802, 1555.194, 1557.897, 1559.834, 1561.887, 1563.856, 1535.818, 1537.837, 1539.827, 1541.867, 1543.772, 1545.768, 1547.764, 1535.855, 1537.92, 1539.875, 1541.905, 1543.903, 1545.854, 1547.871, 1549.908, 1557.858, 1559.846, 1561.851, 1563.835, 0, 0, 0, 0, 1550.802, 1552.831, 1554.897, 1556.897, 0, 0, 0, 0, 1543.804, 1545.869, 1547.865, 1549.805, 0, 0, 0, 0, 1536.79, 1539.759, 1542.691, 1545.759, 1548.719, 1551.835, 1554.707, 1557.714, 1560.756, 1563.697, 1537.828, 1540.804, 1543.726, 1546.769, 1549.698, 1552.749, 1555.862, 1558.796, 1561.737, 1565.76, 1533.177, 1536.68, 1539.622, 1542.445, 1545.646, 1548.485, 1551.763, 1533.139, 1536.207, 1539.487, 1542.141, 1545.127, 1548.153, 1551.433, 1554.22, 1557.324, 1560.406, 1532.322, 1535.331, 1538.348, 1541.278, 1532.238, 1535.493, 1538.507, 1541.482, 1544.521, 1547.337, 1550.38, 1553.582, 1556.3, 1559.4, 1533.363, 1536.476, 1538.212, 1541.983, 1544.813, 1548.062, 1550.77, 1554.162, 1556.829, 1559.949, 1547.437, 1553.448, 1556.468, 1559.291, 1537.852, 1540.774, 1543.699, 1546.773, 1549.698, 1552.776, 1555.862, 1558.742, 1561.839, 1536.781, 1539.743, 1542.735, 1545.769, 1548.737, 1551.88, 1554.742, 1557.776, 1560.722, 1563.742, 1537.861, 1540.801, 1543.742, 1546.799, 1549.847, 1552.743, 1555.881, 1558.777, 1561.789, 1565.814, 1536.815, 1539.839, 1542.709, 1545.738, 1548.851, 1551.866, 1554.714, 1557.736, 1560.76, 1563.732, 1537.796, 1540.815, 1543.709, 1546.75, 1549.719, 1552.755, 1555.831, 1558.739, 1561.774, 1565.756, 1554.925, 1558.128, 1561.035};
// 异想家换算的标定
const double calibrationWave[231] = { 1535.819, 1537.796, 1539.778, 1541.821, 1543.778, 1545.761, 1547.759, 1549.810, 1552.055, 1554.093, 1556.025, 1557.901, 1559.836, 1561.880, 1563.805, 1549.780, 1551.853, 1554.025, 1556.016, 1558.034, 1559.984, 1561.991, 1563.916, 1551.872, 1553.928, 1555.959, 1557.964, 1559.851, 1561.912, 1563.806, 1535.935, 1537.963, 1539.949, 1542.025, 1543.970, 1545.961, 1547.951, 1549.947, 1551.907, 1553.947, 1555.942, 1557.954, 1559.962, 1561.914, 1563.879, 1535.822, 1537.828, 1539.793, 1541.824, 1543.792, 1545.759, 1547.731, 1549.750, 1551.784, 1553.801, 1555.873, 1557.885, 1559.895, 1561.987, 1564.013, 1535.895, 1537.902, 1539.888, 1541.916, 1543.894, 1545.858, 1547.858, 1549.847, 1551.886, 1553.876, 1555.938, 1557.953, 1559.932, 1561.936, 1563.938, 1535.785, 1537.811, 1539.801, 1541.842, 1543.757, 1545.749, 1547.739, 1535.956, 1538.023, 1539.980, 1542.010, 1544.005, 1545.957, 1547.960, 1549.990, 1557.858, 1559.846, 1561.851, 1563.835, 0, 0, 0, 0, 1550.802, 1552.831, 1554.897, 1556.897, 0, 0, 0, 0, 1543.804, 1545.869, 1547.865, 1549.805, 0, 0, 0, 0, 1536.763, 1540.138, 1542.679, 1545.732, 1548.709, 1551.804, 1554.665, 1557.678, 1560.726, 1564.200, 1537.779, 1540.742, 1543.671, 1546.714, 1549.659, 1552.720, 1555.818, 1558.769, 1561.702, 1565.741, 1533.606, 1537.188, 1540.176, 1542.945, 1546.062, 1548.887, 1552.257, 1533.566, 1536.622, 1539.961, 1542.601, 1545.597, 1548.598, 1551.959, 1554.702, 1557.721, 1560.892, 1532.729, 1535.717, 1538.752, 1541.684, 1532.691, 1535.924, 1538.925, 1541.869, 1544.993, 1547.716, 1550.796, 1554.009, 1556.718, 1559.705, 1533.759, 1536.861, 1538.652, 1542.413, 1545.249, 1548.483, 1551.271, 1554.603, 1557.231, 1560.437, 1547.860, 1553.843, 1556.916, 1559.731, 1537.790, 1540.714, 1543.653, 1546.732, 1549.672, 1552.714, 1555.757, 1558.626, 1561.673, 1536.743, 1539.722, 1542.702, 1545.728, 1548.729, 1551.866, 1554.707, 1557.738, 1560.677, 1563.693, 1537.849, 1540.757, 1543.703, 1546.733, 1549.813, 1552.697, 1555.838, 1558.740, 1561.685, 1565.750, 1536.812, 1539.811, 1542.697, 1545.702, 1548.804, 1551.820, 1554.617, 1557.661, 1560.702, 1563.682, 1537.756, 1540.757, 1543.670, 1546.710, 1549.669, 1552.698, 1555.776, 1558.696, 1561.717, 1565.628, 1555.018, 1558.270, 1561.124 };

// 虚拟通道映射相关

// 现在的编号-顺序编号
QString VirtualMap_FBGT_Now = "Time,TCH01-01,TCH01-02,TCH01-03,TCH01-04,TCH01-05,TCH01-06,TCH01-07,TCH01-08,TCH01-09,TCH01-10,TCH01-11,TCH01-12,TCH01-13,TCH01-14,TCH01-15,TCH02-01,TCH02-02,TCH02-03,TCH02-04,TCH02-05,TCH02-06,TCH02-07,TCH02-08,TCH02-09,TCH02-10,TCH02-11,TCH02-12,TCH02-13,TCH02-14,TCH02-15,TCH03-01,TCH03-02,TCH03-03,TCH03-04,TCH03-05,TCH03-06,TCH03-07,TCH03-08,TCH03-09,TCH03-10,TCH03-11,TCH03-12,TCH03-13,TCH03-14,TCH03-15,TCH04-01,TCH04-02,TCH04-03,TCH04-04,TCH04-05,TCH04-06,TCH04-07,TCH04-08,TCH04-09,TCH04-10,TCH04-11,TCH04-12,TCH04-13,TCH04-14,TCH04-15,TCH05-01,TCH05-02,TCH05-03,TCH05-04,TCH05-05,TCH05-06,TCH05-07,TCH05-08,TCH05-09,TCH05-10,TCH05-11,TCH05-12,TCH05-13,TCH05-14,TCH05-15,TCH06-01,TCH06-02,TCH06-03,TCH06-04,TCH06-05,TCH06-06,TCH06-07,TCH06-08,TCH06-09,TCH06-10,TCH06-11,TCH06-12,TCH06-13,TCH06-14,TCH06-15,TCH07-01,TCH07-02,TCH07-03,TCH07-04,TCH08-01,TCH08-02,TCH08-03,TCH08-04,TCH09-01,TCH09-02,TCH09-03,TCH09-04,TCH10-01,TCH10-02,TCH10-03,TCH10-04,TCH10-05,TCH10-06,TCH10-07,TCH10-08,TCH10-09,TCH10-10,TCH11-01,TCH11-02,TCH11-03,TCH11-04,TCH11-05,TCH11-06,TCH11-07,TCH11-08,TCH11-09,TCH11-10,TCH12-01,TCH12-02,TCH12-03,TCH12-04,TCH12-05,TCH12-06,TCH12-07,TCH12-08,TCH12-09,TCH13-01,TCH13-02,TCH13-03,TCH13-04,TCH13-05,TCH13-06,TCH13-07,TCH13-08,TCH13-09,TCH13-10,TCH14-01,TCH14-02,TCH14-03,TCH14-04,TCH14-05,TCH14-06,TCH14-07,TCH14-08,TCH14-09,TCH14-10,TCH15-01,TCH15-02,TCH15-03,TCH15-04,TCH15-05,TCH15-06,TCH15-07,TCH15-08,TCH15-09,TCH15-10,TCH16-01,TCH16-02,TCH16-03,TCH16-04,TCH16-05,TCH16-06,TCH16-07,TCH16-08,TCH16-09,TCH16-10,TCH17-01,TCH17-02,TCH17-03,TCH17-04,TCH17-05,TCH17-06,TCH17-07,TCH17-08,TCH18-01,TCH18-02,TCH18-03,TCH18-04,TCH18-05,TCH18-06,TCH18-07,TCH18-08,TCH19-01,TCH19-02,TCH19-03,TCH19-04,TCH19-05,TCH19-06,TCH19-07,TCH19-08,TCH20-01,TCH20-02,TCH20-03,TCH20-04,TCH20-05,TCH20-06,TCH20-07,TCH20-08,TCH21-01,TCH21-02,TCH21-03,TCH21-04,TCH21-05,TCH21-06,TCH21-07,TCH21-08,TCH22-01,TCH22-02,TCH22-03,TCH22-04,TCH22-05,TCH22-06,TCH22-07,TCH22-08";
QString VirtualMap_FBGS_Now = "Time,SCH01-01,SCH01-02,SCH01-03,SCH01-04,SCH01-05,SCH01-06,SCH01-07,SCH01-08,SCH01-09,SCH01-10,SCH01-11,SCH01-12,SCH01-13,SCH01-14,SCH01-15,SCH02-01,SCH02-02,SCH02-03,SCH02-04,SCH02-05,SCH02-06,SCH02-07,SCH02-08,SCH02-09,SCH02-10,SCH02-11,SCH02-12,SCH02-13,SCH02-14,SCH02-15,SCH03-01,SCH03-02,SCH03-03,SCH03-04,SCH03-05,SCH03-06,SCH03-07,SCH03-08,SCH03-09,SCH03-10,SCH03-11,SCH03-12,SCH03-13,SCH03-14,SCH03-15,SCH04-01,SCH04-02,SCH04-03,SCH04-04,SCH04-05,SCH04-06,SCH04-07,SCH04-08,SCH04-09,SCH04-10,SCH04-11,SCH04-12,SCH04-13,SCH04-14,SCH04-15,SCH05-01,SCH05-02,SCH05-03,SCH05-04,SCH05-05,SCH05-06,SCH05-07,SCH05-08,SCH05-09,SCH05-10,SCH05-11,SCH05-12,SCH05-13,SCH05-14,SCH05-15,SCH06-01,SCH06-02,SCH06-03,SCH06-04,SCH06-05,SCH06-06,SCH06-07,SCH06-08,SCH06-09,SCH06-10,SCH06-11,SCH06-12,SCH06-13,SCH06-14,SCH06-15";
QString VirtualMap_DS18_Now = "Time,DCH01-01,DCH01-02,DCH01-03,DCH01-04,DCH01-05,DCH01-06,DCH01-07,DCH01-08,DCH02-01,DCH02-02,DCH02-03,DCH02-04,DCH02-05,DCH02-06,DCH02-07,DCH02-08,DCH03-01,DCH03-02,DCH03-03,DCH03-04,DCH03-05,DCH03-06,DCH03-07,DCH03-08,DCH04-01,DCH04-02,DCH04-03,DCH04-04,DCH04-05,DCH04-06,DCH04-07,DCH04-08,DCH05-01,DCH05-02,DCH05-03,DCH05-04,DCH05-05,DCH05-06,DCH05-07,DCH05-08,DCH06-01,DCH06-02,DCH06-03,DCH06-04,DCH06-05,DCH06-06,DCH06-07,DCH06-08,DCH07-01,DCH07-02,DCH07-03,DCH07-04";
// 原来的编号-映射编号
QString VirtualMap_FBGT_Ori = "CH11-01,CH11-02,CH11-03,CH11-04,CH11-05,CH11-06,CH11-07,CH11-08,CH11-09,CH11-10,CH11-11,CH11-12,CH11-13,CH11-14,CH11-15,CH12-01,CH12-02,CH12-03,CH12-04,CH12-05,CH12-06,CH12-07,CH12-08,CH12-09,CH12-10,CH12-11,CH12-12,CH12-13,CH12-14,CH12-15,CH13-01,CH13-02,CH13-03,CH13-04,CH13-05,CH13-06,CH13-07,CH13-08,CH13-09,CH13-10,CH13-11,CH13-12,CH13-13,CH13-14,CH13-15,CH08-01,CH08-02,CH08-03,CH08-04,CH08-05,CH08-06,CH08-07,CH08-08,CH08-09,CH08-10,CH08-11,CH08-12,CH08-13,CH08-14,CH08-15,CH14-07,CH14-06,CH14-05,CH14-04,CH14-03,CH14-02,CH14-01,CH09-01,CH09-02,CH09-03,CH09-04,CH09-05,CH09-06,CH09-07,CH09-08,CH15-08,CH15-07,CH15-06,CH15-05,CH15-04,CH15-03,CH15-02,CH15-01,CH10-01,CH10-02,CH10-03,CH10-04,CH10-05,CH10-06,CH10-07,CH16-01,CH16-02,CH16-03,CH16-04,CH17-01,CH17-02,CH17-03,CH17-04,CH18-01,CH18-02,CH18-03,CH18-04,CH19-01,CH19-02,CH19-03,CH19-04,CH19-05,CH19-06,CH19-07,CH19-08,CH19-09,CH19-10,CH20-01,CH20-02,CH20-03,CH20-04,CH20-05,CH20-06,CH20-07,CH20-08,CH20-09,CH20-10,CH27-01,CH27-02,CH27-03,CH27-04,CH27-05,CH27-06,CH27-07,CH27-08,CH27-09,CH28-01,CH28-02,CH28-03,CH28-04,CH28-05,CH28-06,CH28-07,CH28-08,CH28-09,CH28-10,CH29-01,CH29-02,CH29-03,CH29-04,CH29-05,CH29-06,CH29-07,CH29-08,CH29-09,CH29-10,CH30-01,CH30-02,CH30-03,CH30-04,CH30-05,CH30-06,CH30-07,CH30-08,CH30-09,CH30-10,CH31-01,CH31-02,CH31-03,CH31-04,CH31-05,CH31-06,CH31-07,CH31-08,CH31-09,CH31-10,CH24-01,CH24-02,CH24-03,CH24-04,CH24-05,CH24-06,CH24-07,CH24-08,CH24-09,CH24-10,CH26-01,CH26-02,CH26-03,CH26-04,CH25-09,CH25-10,CH25-01,CH25-02,CH25-03,CH25-04,CH25-05,CH25-06,CH25-07,CH25-08,CH22-01,CH22-02,CH22-03,CH22-04,CH22-05,CH22-06,CH22-07,CH22-08,CH22-09,CH22-10,CH23-01,CH23-02,CH23-03,CH23-04,CH32-03,CH32-02,CH21-01,CH21-02,CH21-03,CH21-04,CH21-05,CH21-06,CH21-07,CH32-01";
QString VirtualMap_FBGS_Ori = "CH04-01,CH04-02,CH04-03,CH04-04,CH04-05,CH04-06,CH04-07,CH04-08,CH04-09,CH04-10,CH04-11,CH04-12,CH04-13,CH04-14,CH04-15,CH05-01,CH05-02,CH05-03,CH05-04,CH05-05,CH05-06,CH05-07,CH05-08,CH05-09,CH05-10,CH05-11,CH05-12,CH05-13,CH05-14,CH05-15,CH06-01,CH06-02,CH06-03,CH06-04,CH06-05,CH06-06,CH06-07,CH06-08,CH06-09,CH06-10,CH06-11,CH06-12,CH06-13,CH06-14,CH06-15,CH01-01,CH01-02,CH01-03,CH01-04,CH01-05,CH01-06,CH01-07,CH01-08,CH01-09,CH01-10,CH01-11,CH01-12,CH01-13,CH01-14,CH01-15,CH07-07,CH07-06,CH07-05,CH07-04,CH07-03,CH07-02,CH07-01,CH02-01,CH02-02,CH02-03,CH02-04,CH02-05,CH02-06,CH02-07,CH02-08,CH03-01,CH03-02,CH03-03,CH03-04,CH03-05,CH03-06,CH03-07,CH03-08,CH03-09,CH03-10,CH03-11,CH03-12,CH03-13,CH03-14,CH03-15";
// 数组下标变换
const int VirtualMap_FBGT_Index[219] = {30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,75,76,77,78,79,80,81,15,16,17,18,19,20,21,22,82,83,84,85,86,87,88,89,23,24,25,26,27,28,29,90,91,92,93,98,99,100,101,106,107,108,109,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,155,156,157,158,159,160,161,162,163,164,175,176,177,178,173,174,165,166,167,168,169,170,171,172,141,142,143,144,145,146,147,148,149,150,151,152,153,154,230,229,134,135,136,137,138,139,140,228};
const int VirtualMap_FBGS_Index[90] = { 38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,89,88,87,86,85,84,83,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37 };

// 时间工具，2017-06-17 23:17:13转20170617231713
QString TimeToTimeNum(QString Time)
{
	QString TimeNum(Time);
	TimeNum.replace(QRegExp("\\-"), "");
	TimeNum.replace(QRegExp("\\ "), "");
	TimeNum.replace(QRegExp("\\:"), "");
	return TimeNum;
}

// 获取文件名-不带后缀
QString getFileName(QString filePath)
{
	QString currentFileName = filePath.right(filePath.size() - filePath.lastIndexOf('/') - 1);
	return currentFileName;
}

// 获取各项数据该读取的csv文件名列表
QStringList get_DS18B20_csv(const QString &dir)
{
	QString CH1 = dir + "/通道1.csv";
	QString CH2 = dir + "/通道2.csv";
	QString CH3 = dir + "/通道3.csv";
	QString CH4 = dir + "/通道4.csv";
	QString CH5 = dir + "/通道5.csv";
	QString CH6 = dir + "/通道6.csv";
	QString CH7 = dir + "/通道7.csv";
	QString CH8 = dir + "/通道8.csv";
	QStringList CH{ CH1,CH2,CH3,CH4,CH5,CH6,CH7,CH8 };
	return CH;
}

QStringList get_CCD_csv(const QString &dir)
{
	QString CH1 = dir + "/CCD数据值.csv";
	QStringList CH{ CH1 };
	return CH;
}

QStringList get_FBGT_csv(const QString &dir)
{
	QString CH08 = dir + "/通道8.csv";
	QString CH09 = dir + "/通道9.csv";
	QString CH10 = dir + "/通道10.csv";
	QString CH11 = dir + "/通道11.csv";
	QString CH12 = dir + "/通道12.csv";
	QString CH13 = dir + "/通道13.csv";
	QString CH14 = dir + "/通道14.csv";
	QString CH15 = dir + "/通道15.csv";
	QString CH16 = dir + "/通道16.csv";
	QString CH17 = dir + "/通道17.csv";
	QString CH18 = dir + "/通道18.csv";
	QString CH19 = dir + "/通道19.csv";
	QString CH20 = dir + "/通道20.csv";
	QString CH21 = dir + "/通道21.csv";
	QString CH22 = dir + "/通道22.csv";
	QString CH23 = dir + "/通道23.csv";
	QString CH24 = dir + "/通道24.csv";
	QString CH25 = dir + "/通道25.csv";
	QString CH26 = dir + "/通道26.csv";
	QString CH27 = dir + "/通道27.csv";
	QString CH28 = dir + "/通道28.csv";
	QString CH29 = dir + "/通道29.csv";
	QString CH30 = dir + "/通道30.csv";
	QString CH31 = dir + "/通道31.csv";
	QString CH32 = dir + "/通道32.csv";
	QStringList CH{ CH08,CH09,CH10,CH11,CH12,CH13,CH14,CH15,CH16,CH17,CH18,CH19,CH20,CH21,CH22,CH23,CH24,CH25,CH26,CH27,CH28,CH29,CH30,CH31,CH32 };
	return CH;
}

QStringList get_FBGS_csv(const QString &dir)
{
	QString CH01 = dir + "/通道1.csv";
	QString CH02 = dir + "/通道2.csv";
	QString CH03 = dir + "/通道3.csv";
	QString CH04 = dir + "/通道4.csv";
	QString CH05 = dir + "/通道5.csv";
	QString CH06 = dir + "/通道6.csv";
	QString CH07 = dir + "/通道7.csv";
	QStringList CH{ CH01,CH02,CH03,CH04,CH05,CH06,CH07 };
	return CH;
}

// 波长修复算法，剔除多余的、非标定段的波长，实在没有给0
bool WaveFix(vector<double> &input, vector<double> &standWave, double output[])
{
	int index = 0;
	for (auto i = standWave.begin(); i != standWave.end(); ++i)
	{
		for (auto j = input.begin(); j != input.end(); ++j)
		{
			// 找波长比标定时数据大的，并且差值小于1.75（166多度以内）
			if ((*j - *i) >= 0 && (*j - *i) <= 1.75)
			{
				output[index] = *j; // 这个*j就放在index处
				break;
			}
			else
			{
				output[index] = 0;
			}
		}
		++index;
	}
	return true;
}

// DS18B20标准化
int Stand_DS18B20(QStringList &CH, mat &DS18B20_All_Mat, QStringList &XLabelName)
{	// DS18B20内部ID
	QMap<QString, int> DS18B20_ID;
	DS18B20_ID.insert("ID:28ffcdfa001604cb", 0);
	DS18B20_ID.insert("ID:28ff7eeda0160301", 1);
	DS18B20_ID.insert("ID:28ffa203011604fc", 2);
	DS18B20_ID.insert("ID:28ffd7cc0016044b", 3);
	DS18B20_ID.insert("ID:28ff6ba7a0160589", 4);
	DS18B20_ID.insert("ID:28ff28f8041603d9", 5);
	DS18B20_ID.insert("ID:28ff280c01160410", 6);
	DS18B20_ID.insert("ID:28ff4a2305160375", 7);
	DS18B20_ID.insert("ID:28ffaf1fb2150108", 8);
	DS18B20_ID.insert("ID:28ff921db2150167", 9);
	DS18B20_ID.insert("ID:28ff86eb041603f8", 10);
	DS18B20_ID.insert("ID:28ffd3dd041603fe", 11);
	DS18B20_ID.insert("ID:28ff71c100160479", 12);
	DS18B20_ID.insert("ID:28ffb81cb2150311", 13);
	DS18B20_ID.insert("ID:28ff6a0c0116047a", 14);
	DS18B20_ID.insert("ID:28ffa2dd00160443", 15);
	DS18B20_ID.insert("ID:28ff1d93a01603e3", 16);
	DS18B20_ID.insert("ID:28ff78bea01603cd", 17);
	DS18B20_ID.insert("ID:28ff4ec300160495", 18);
	DS18B20_ID.insert("ID:28ffaddc001604a3", 19);
	DS18B20_ID.insert("ID:28ffb6e500160474", 20);
	DS18B20_ID.insert("ID:28ffa3f7001604e5", 21);
	DS18B20_ID.insert("ID:28ff30f70016041c", 22);
	DS18B20_ID.insert("ID:28ff95f7001604fd", 23);
	DS18B20_ID.insert("ID:28ffe6ce00160405", 24);
	DS18B20_ID.insert("ID:28ff783db215044f", 25);
	DS18B20_ID.insert("ID:28ff52c600160449", 26);
	DS18B20_ID.insert("ID:28ffed30b2150334", 27);
	DS18B20_ID.insert("ID:28ffdcc20016042e", 28);
	DS18B20_ID.insert("ID:28ffd827b215045f", 29);
	DS18B20_ID.insert("ID:28ff3425051603b3", 30);
	DS18B20_ID.insert("ID:28ff247eb2150310", 31);
	DS18B20_ID.insert("ID:28ff76e500160456", 32);
	DS18B20_ID.insert("ID:28ffa5c30016043f", 33);
	DS18B20_ID.insert("ID:28ff2d22b2150195", 34);
	DS18B20_ID.insert("ID:28ffcd0d01160497", 35);
	DS18B20_ID.insert("ID:28ff55a7a01605af", 36);
	DS18B20_ID.insert("ID:28ff56d7001604e1", 37);
	DS18B20_ID.insert("ID:28ff3ccba0160491", 38);
	DS18B20_ID.insert("ID:28ff0091a01604f7", 39);
	DS18B20_ID.insert("ID:28ff80efa01605df", 40);
	DS18B20_ID.insert("ID:28ffd7c6a0160325", 41);
	DS18B20_ID.insert("ID:28ff04ada01605ec", 42);
	DS18B20_ID.insert("ID:28fffdd4a0160582", 43);
	DS18B20_ID.insert("ID:28ff87caa0160421", 44);
	DS18B20_ID.insert("ID:28ff1d9da0160475", 45);
	DS18B20_ID.insert("ID:28fffdada01605b9", 46);
	DS18B20_ID.insert("ID:28ff44d3a01605b8", 47);
	DS18B20_ID.insert("ID:28ff538da0160406", 48);
	DS18B20_ID.insert("ID:28ff387da0160416", 49);
	DS18B20_ID.insert("ID:28ffcacfa01605fb", 50);
	DS18B20_ID.insert("ID:28ff16a8a0160592", 51);

	// 时间
	QStringList timeName2;

	// 传感器ID编号
	QStringList DataNameCH1;
	QStringList DataNameCH2;
	QStringList DataNameCH3;
	QStringList DataNameCH4;
	QStringList DataNameCH5;
	QStringList DataNameCH6;
	QStringList DataNameCH7;
	QStringList DataNameCH8;

	// 由文件名输出mat、传感器ID编号、时间
	mat DS18B20_CH1_Mat = JIO::readCsv(CH[0], DataNameCH1, XLabelName);
	mat DS18B20_CH2_Mat = JIO::readCsv(CH[1], DataNameCH2, timeName2);
	mat DS18B20_CH3_Mat = JIO::readCsv(CH[2], DataNameCH3, timeName2);
	mat DS18B20_CH4_Mat = JIO::readCsv(CH[3], DataNameCH4, timeName2);
	mat DS18B20_CH5_Mat = JIO::readCsv(CH[4], DataNameCH5, timeName2);
	mat DS18B20_CH6_Mat = JIO::readCsv(CH[5], DataNameCH6, timeName2);
	mat DS18B20_CH7_Mat = JIO::readCsv(CH[6], DataNameCH7, timeName2);
	mat DS18B20_CH8_Mat = JIO::readCsv(CH[7], DataNameCH8, timeName2);

	// 定一个行数
	int row = 0;
	if (DS18B20_CH1_Mat.n_rows >= DS18B20_CH2_Mat.n_rows)
		row = DS18B20_CH1_Mat.n_rows;
	else
		row = DS18B20_CH2_Mat.n_rows;

	// 构造存所有传感器数据的Mat 规定52列
	DS18B20_All_Mat.set_size(row, 52);
	DS18B20_All_Mat.fill(0.0);

	// CH1通道排序
	for (int i = 1; i < DataNameCH1.size(); ++i)
	{
		// DataNameCH1第0个为Time，注意排除
		int col = DS18B20_ID.value(DataNameCH1[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH1_Mat.col(i - 1);
		//		qDebug()<<DataNameCH1[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH2通道排序
	for (int i = 1; i < DataNameCH2.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH2[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH2_Mat.col(i - 1);
		//			qDebug()<< DataNameCH2[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH3通道排序
	for (int i = 1; i < DataNameCH3.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH3[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH3_Mat.col(i - 1);
		//		qDebug()<< DataNameCH3[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH4通道排序
	for (int i = 1; i < DataNameCH4.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH4[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH4_Mat.col(i - 1);
		//		qDebug()<< DataNameCH4[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH5通道排序
	for (int i = 1; i < DataNameCH5.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH5[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH5_Mat.col(i - 1);
		//		qDebug()<< DataNameCH5[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH6通道排序
	for (int i = 1; i < DataNameCH6.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH6[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH6_Mat.col(i - 1);
		//		qDebug()<< DataNameCH6[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH7通道排序
	for (int i = 1; i < DataNameCH7.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH7[i], -1);
		if (col > 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH7_Mat.col(i - 1);
		//		qDebug()<< DataNameCH7[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	// CH8通道排序
	for (int i = 1; i < DataNameCH8.size(); ++i)
	{
		int col = DS18B20_ID.value(DataNameCH8[i], -1);
		if (col >= 0 && col <= 51)
			DS18B20_All_Mat.col(col) = DS18B20_CH8_Mat.col(i - 1);
		//		qDebug()<< DataNameCH8[i]<<" "<< col<<" " << i-1;
	}
	//	qDebug()<<" ";
	return 0;
}

// DS18B20标准化-只输入CH，返回mat
mat Stand_DS18B20(QStringList &CH)
{
	mat DS18B20_All_Mat;
	QString CH1 = CH[0];
	QString CH2 = CH[1];
	QString CH3 = CH[2];
	QString CH4 = CH[3];
	QString CH5 = CH[4];
	QString CH6 = CH[5];
	QString CH7 = CH[6];
	QString CH8 = CH[7];

	// 时间
	QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataNameCH1;
	QStringList DataNameCH2;
	QStringList DataNameCH3;
	QStringList DataNameCH4;
	QStringList DataNameCH5;
	QStringList DataNameCH6;
	QStringList DataNameCH7;
	QStringList DataNameCH8;

	// 由文件名输出mat、传感器ID编号、时间
	mat DS18B20_CH1_Mat = JIO::readCsv(CH1, DataNameCH1, XLabelName);
	mat DS18B20_CH2_Mat = JIO::readCsv(CH2, DataNameCH2, XLabelName2);
	mat DS18B20_CH3_Mat = JIO::readCsv(CH3, DataNameCH3, XLabelName2);
	mat DS18B20_CH4_Mat = JIO::readCsv(CH4, DataNameCH4, XLabelName2);
	mat DS18B20_CH5_Mat = JIO::readCsv(CH5, DataNameCH5, XLabelName2);
	mat DS18B20_CH6_Mat = JIO::readCsv(CH6, DataNameCH6, XLabelName2);
	mat DS18B20_CH7_Mat = JIO::readCsv(CH7, DataNameCH7, XLabelName2);
	mat DS18B20_CH8_Mat = JIO::readCsv(CH8, DataNameCH8, XLabelName2);

	//    qDebug()<<"InputFileRow"<<InputFileRow;
	//    qDebug()<<"InputFileCol"<<InputFileCol;
	//    qDebug()<<"DataName"<<DataName;
	//    qDebug()<<"XLabelName"<<XLabelName[0];
	//    qDebug()<<"DS18B20_CH1_Mat"<<DS18B20_CH1_Mat(0,0);

	// 初始化排序Mat
	mat DS18B20_CH1_OrderMat(DS18B20_CH1_Mat.n_rows, DS18B20_CH1_Mat.n_cols);
	mat DS18B20_CH2_OrderMat(DS18B20_CH2_Mat.n_rows, DS18B20_CH2_Mat.n_cols);
	mat DS18B20_CH3_OrderMat(DS18B20_CH3_Mat.n_rows, DS18B20_CH3_Mat.n_cols);
	mat DS18B20_CH4_OrderMat(DS18B20_CH4_Mat.n_rows, DS18B20_CH4_Mat.n_cols);
	mat DS18B20_CH5_OrderMat(DS18B20_CH5_Mat.n_rows, DS18B20_CH5_Mat.n_cols);
	mat DS18B20_CH6_OrderMat(DS18B20_CH6_Mat.n_rows, DS18B20_CH6_Mat.n_cols);
	mat DS18B20_CH7_OrderMat(DS18B20_CH7_Mat.n_rows, DS18B20_CH7_Mat.n_cols);
	mat DS18B20_CH8_OrderMat(DS18B20_CH8_Mat.n_rows, DS18B20_CH8_Mat.n_cols);

	// 0矩阵
	mat DS18B20_0(DS18B20_CH1_Mat.n_rows, 1);
	DS18B20_0.fill(0);
	// 原始矩阵曾一列处理错情况
	DS18B20_CH1_Mat = join_rows(DS18B20_CH1_Mat, DS18B20_0);
	DS18B20_CH2_Mat = join_rows(DS18B20_CH2_Mat, DS18B20_0);
	DS18B20_CH3_Mat = join_rows(DS18B20_CH3_Mat, DS18B20_0);
	DS18B20_CH4_Mat = join_rows(DS18B20_CH4_Mat, DS18B20_0);
	DS18B20_CH5_Mat = join_rows(DS18B20_CH5_Mat, DS18B20_0);
	DS18B20_CH6_Mat = join_rows(DS18B20_CH6_Mat, DS18B20_0);
	DS18B20_CH7_Mat = join_rows(DS18B20_CH7_Mat, DS18B20_0);
	DS18B20_CH8_Mat = join_rows(DS18B20_CH8_Mat, DS18B20_0);

	// 由ID来排序，建立索引规则
	int CH10 = DataNameCH1.indexOf("ID:28ffcdfa001604cb"); if (CH10 == -1) CH10 = 8;
	int CH11 = DataNameCH1.indexOf("ID:28ff7eeda0160301"); if (CH11 == -1) CH11 = 8;
	int CH12 = DataNameCH1.indexOf("ID:28ffa203011604fc"); if (CH12 == -1) CH12 = 8;
	int CH13 = DataNameCH1.indexOf("ID:28ffd7cc0016044b"); if (CH13 == -1) CH13 = 8;
	int CH14 = DataNameCH1.indexOf("ID:28ff6ba7a0160589"); if (CH14 == -1) CH14 = 8;
	int CH15 = DataNameCH1.indexOf("ID:28ff28f8041603d9"); if (CH15 == -1) CH15 = 8;
	int CH16 = DataNameCH1.indexOf("ID:28ff280c01160410"); if (CH16 == -1) CH16 = 8;
	int CH17 = DataNameCH1.indexOf("ID:28ff4a2305160375"); if (CH17 == -1) CH17 = 8;

	int CH20 = DataNameCH2.indexOf("ID:28ffaf1fb2150108"); if (CH20 == -1) CH20 = 8;
	int CH21 = DataNameCH2.indexOf("ID:28ff921db2150167"); if (CH21 == -1) CH21 = 8;
	int CH22 = DataNameCH2.indexOf("ID:28ff86eb041603f8"); if (CH22 == -1) CH22 = 8;
	int CH23 = DataNameCH2.indexOf("ID:28ffd3dd041603fe"); if (CH23 == -1) CH23 = 8;
	int CH24 = DataNameCH2.indexOf("ID:28ff71c100160479"); if (CH24 == -1) CH24 = 8;
	int CH25 = DataNameCH2.indexOf("ID:28ffb81cb2150311"); if (CH25 == -1) CH25 = 8;
	int CH26 = DataNameCH2.indexOf("ID:28ff6a0c0116047a"); if (CH26 == -1) CH26 = 8;
	int CH27 = DataNameCH2.indexOf("ID:28ffa2dd00160443"); if (CH27 == -1) CH27 = 8;

	int CH30 = DataNameCH3.indexOf("ID:28ff1d93a01603e3"); if (CH30 == -1) CH30 = 8;
	int CH31 = DataNameCH3.indexOf("ID:28ff78bea01603cd"); if (CH31 == -1) CH31 = 8;
	int CH32 = DataNameCH3.indexOf("ID:28ff4ec300160495"); if (CH32 == -1) CH32 = 8;
	int CH33 = DataNameCH3.indexOf("ID:28ffaddc001604a3"); if (CH33 == -1) CH33 = 8;
	int CH34 = DataNameCH3.indexOf("ID:28ffb6e500160474"); if (CH34 == -1) CH34 = 8;
	int CH35 = DataNameCH3.indexOf("ID:28ffa3f7001604e5"); if (CH35 == -1) CH35 = 8;
	int CH36 = DataNameCH3.indexOf("ID:28ff30f70016041c"); if (CH36 == -1) CH36 = 8;
	int CH37 = DataNameCH3.indexOf("ID:28ff95f7001604fd"); if (CH37 == -1) CH37 = 8;

	int CH40 = DataNameCH4.indexOf("ID:28ffe6ce00160405"); if (CH40 == -1) CH40 = 8;
	int CH41 = DataNameCH4.indexOf("ID:28ff783db215044f"); if (CH41 == -1) CH41 = 8;
	int CH42 = DataNameCH4.indexOf("ID:28ff52c600160449"); if (CH42 == -1) CH42 = 8;
	int CH43 = DataNameCH4.indexOf("ID:28ffed30b2150334"); if (CH43 == -1) CH43 = 8;
	int CH44 = DataNameCH4.indexOf("ID:28ffdcc20016042e"); if (CH44 == -1) CH44 = 8;
	int CH45 = DataNameCH4.indexOf("ID:28ffd827b215045f"); if (CH45 == -1) CH45 = 8;
	int CH46 = DataNameCH4.indexOf("ID:28ff3425051603b3"); if (CH46 == -1) CH46 = 8;
	int CH47 = DataNameCH4.indexOf("ID:28ff247eb2150310"); if (CH47 == -1) CH47 = 8;

	int CH50 = DataNameCH5.indexOf("ID:28ff76e500160456"); if (CH50 == -1) CH50 = 8;
	int CH51 = DataNameCH5.indexOf("ID:28ffa5c30016043f"); if (CH51 == -1) CH51 = 8;
	int CH52 = DataNameCH5.indexOf("ID:28ff2d22b2150195"); if (CH52 == -1) CH52 = 8;
	int CH53 = DataNameCH5.indexOf("ID:28ffcd0d01160497"); if (CH53 == -1) CH53 = 8;
	int CH54 = DataNameCH5.indexOf("ID:28ff55a7a01605af"); if (CH54 == -1) CH54 = 8;
	int CH55 = DataNameCH5.indexOf("ID:28ff56d7001604e1"); if (CH55 == -1) CH55 = 8;
	int CH56 = DataNameCH5.indexOf("ID:28ff3ccba0160491"); if (CH56 == -1) CH56 = 8;
	int CH57 = DataNameCH5.indexOf("ID:28ff0091a01604f7"); if (CH57 == -1) CH57 = 8;

	int CH60 = DataNameCH6.indexOf("ID:28ff80efa01605df"); if (CH60 == -1) CH60 = 8;
	int CH61 = DataNameCH6.indexOf("ID:28ffd7c6a0160325"); if (CH61 == -1) CH61 = 8;
	int CH62 = DataNameCH6.indexOf("ID:28ff04ada01605ec"); if (CH62 == -1) CH62 = 8;
	int CH63 = DataNameCH6.indexOf("ID:28fffdd4a0160582"); if (CH63 == -1) CH63 = 8;
	int CH64 = DataNameCH6.indexOf("ID:28ff87caa0160421"); if (CH64 == -1) CH64 = 8;
	int CH65 = DataNameCH6.indexOf("ID:28ff1d9da0160475"); if (CH65 == -1) CH65 = 8;
	int CH66 = DataNameCH6.indexOf("ID:28fffdada01605b9"); if (CH66 == -1) CH66 = 8;
	int CH67 = DataNameCH6.indexOf("ID:28ff44d3a01605b8"); if (CH67 == -1) CH67 = 8;

	int CH70 = DataNameCH7.indexOf("ID:28ff538da0160406"); if (CH70 == -1) CH70 = 8;
	int CH71 = DataNameCH7.indexOf("ID:28ff387da0160416"); if (CH71 == -1) CH71 = 8;
	int CH72 = DataNameCH7.indexOf("ID:28ffcacfa01605fb"); if (CH72 == -1) CH72 = 8;
	int CH73 = DataNameCH7.indexOf("ID:28ff16a8a0160592"); if (CH73 == -1) CH73 = 8;


	// mat根据ID按列排序
	DS18B20_CH1_OrderMat.col(0) = DS18B20_CH1_Mat.col(CH10);
	DS18B20_CH1_OrderMat.col(1) = DS18B20_CH1_Mat.col(CH11);
	DS18B20_CH1_OrderMat.col(2) = DS18B20_CH1_Mat.col(CH12);
	DS18B20_CH1_OrderMat.col(3) = DS18B20_CH1_Mat.col(CH13);
	DS18B20_CH1_OrderMat.col(4) = DS18B20_CH1_Mat.col(CH14);
	DS18B20_CH1_OrderMat.col(5) = DS18B20_CH1_Mat.col(CH15);
	DS18B20_CH1_OrderMat.col(6) = DS18B20_CH1_Mat.col(CH16);
	DS18B20_CH1_OrderMat.col(7) = DS18B20_CH1_Mat.col(CH17);

	DS18B20_CH2_OrderMat.col(0) = DS18B20_CH2_Mat.col(CH20);
	DS18B20_CH2_OrderMat.col(1) = DS18B20_CH2_Mat.col(CH21);
	DS18B20_CH2_OrderMat.col(2) = DS18B20_CH2_Mat.col(CH22);
	DS18B20_CH2_OrderMat.col(3) = DS18B20_CH2_Mat.col(CH23);
	DS18B20_CH2_OrderMat.col(4) = DS18B20_CH2_Mat.col(CH24);
	DS18B20_CH2_OrderMat.col(5) = DS18B20_CH2_Mat.col(CH25);
	DS18B20_CH2_OrderMat.col(6) = DS18B20_CH2_Mat.col(CH26);
	DS18B20_CH2_OrderMat.col(7) = DS18B20_CH2_Mat.col(CH27);

	DS18B20_CH3_OrderMat.col(0) = DS18B20_CH3_Mat.col(CH30);
	DS18B20_CH3_OrderMat.col(1) = DS18B20_CH3_Mat.col(CH31);
	DS18B20_CH3_OrderMat.col(2) = DS18B20_CH3_Mat.col(CH32);
	DS18B20_CH3_OrderMat.col(3) = DS18B20_CH3_Mat.col(CH33);
	DS18B20_CH3_OrderMat.col(4) = DS18B20_CH3_Mat.col(CH34);
	DS18B20_CH3_OrderMat.col(5) = DS18B20_CH3_Mat.col(CH35);
	DS18B20_CH3_OrderMat.col(6) = DS18B20_CH3_Mat.col(CH36);
	DS18B20_CH3_OrderMat.col(7) = DS18B20_CH3_Mat.col(CH37);

	DS18B20_CH4_OrderMat.col(0) = DS18B20_CH4_Mat.col(CH40);
	DS18B20_CH4_OrderMat.col(1) = DS18B20_CH4_Mat.col(CH41);
	DS18B20_CH4_OrderMat.col(2) = DS18B20_CH4_Mat.col(CH42);
	DS18B20_CH4_OrderMat.col(3) = DS18B20_CH4_Mat.col(CH43);
	DS18B20_CH4_OrderMat.col(4) = DS18B20_CH4_Mat.col(CH44);
	DS18B20_CH4_OrderMat.col(5) = DS18B20_CH4_Mat.col(CH45);
	DS18B20_CH4_OrderMat.col(6) = DS18B20_CH4_Mat.col(CH46);
	DS18B20_CH4_OrderMat.col(7) = DS18B20_CH4_Mat.col(CH47);

	DS18B20_CH5_OrderMat.col(0) = DS18B20_CH5_Mat.col(CH50);
	DS18B20_CH5_OrderMat.col(1) = DS18B20_CH5_Mat.col(CH51);
	DS18B20_CH5_OrderMat.col(2) = DS18B20_CH5_Mat.col(CH52);
	DS18B20_CH5_OrderMat.col(3) = DS18B20_CH5_Mat.col(CH53);
	DS18B20_CH5_OrderMat.col(4) = DS18B20_CH5_Mat.col(CH54);
	DS18B20_CH5_OrderMat.col(5) = DS18B20_CH5_Mat.col(CH55);
	DS18B20_CH5_OrderMat.col(6) = DS18B20_CH5_Mat.col(CH56);
	DS18B20_CH5_OrderMat.col(7) = DS18B20_CH5_Mat.col(CH57);

	DS18B20_CH6_OrderMat.col(0) = DS18B20_CH6_Mat.col(CH60);
	DS18B20_CH6_OrderMat.col(1) = DS18B20_CH6_Mat.col(CH61);
	DS18B20_CH6_OrderMat.col(2) = DS18B20_CH6_Mat.col(CH62);
	DS18B20_CH6_OrderMat.col(3) = DS18B20_CH6_Mat.col(CH63);
	DS18B20_CH6_OrderMat.col(4) = DS18B20_CH6_Mat.col(CH64);
	DS18B20_CH6_OrderMat.col(5) = DS18B20_CH6_Mat.col(CH65);
	DS18B20_CH6_OrderMat.col(6) = DS18B20_CH6_Mat.col(CH66);
	DS18B20_CH6_OrderMat.col(7) = DS18B20_CH6_Mat.col(CH67);

	DS18B20_CH7_OrderMat.col(0) = DS18B20_CH7_Mat.col(CH70);
	DS18B20_CH7_OrderMat.col(1) = DS18B20_CH7_Mat.col(CH71);
	DS18B20_CH7_OrderMat.col(2) = DS18B20_CH7_Mat.col(CH72);
	DS18B20_CH7_OrderMat.col(3) = DS18B20_CH7_Mat.col(CH73);

	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,0);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,1);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,2);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,3);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,4);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,5);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,6);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH3_OrderMat(0,7);

	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,0);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,1);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,2);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,3);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,4);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,5);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,6);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH2_OrderMat(0,7);

	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH7_OrderMat(0,0);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH7_OrderMat(0,1);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH7_OrderMat(0,2);
	//        qDebug()<<"DS18B20_CH1_OrderMat"<<DS18B20_CH7_OrderMat(0,3);

	// 矩阵合并
	DS18B20_All_Mat = join_rows(DS18B20_CH1_OrderMat, DS18B20_CH2_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH3_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH4_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH5_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH6_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH7_OrderMat);
	DS18B20_All_Mat = join_rows(DS18B20_All_Mat, DS18B20_CH8_OrderMat);

	qDebug() << "电类矩阵行列：" << DS18B20_All_Mat.n_rows << " " << DS18B20_All_Mat.n_cols;
	//	qDebug()<<"All_Mat(0,0)、All_Mat(0,0)："<<DS18B20_All_Mat(0,0)<<" "<<DS18B20_All_Mat(0,1);
	//	qDebug()<<"CH01_Mat(0,0)、CH01_Mat(0,1)："<<DS18B20_CH1_OrderMat(0,0)<<" "<<DS18B20_CH1_OrderMat(0,1);
	return DS18B20_All_Mat;
}

// CCD标准化
int Stand_CCD(QStringList &CH, mat &All_Mat, QStringList &XLabelName)
{
	QString CH1 = CH[0]; // 就一份文件
	// 传感器ID编号
	QStringList DataNameCH1;
	// 由文件名输出mat、传感器ID编号、时间
	All_Mat = JIO::readCsv(CH1, DataNameCH1, XLabelName);
	qDebug() << "CCD矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	qDebug() << "All_Mat(0,0)、All_Mat(0,0)：" << All_Mat(0, 0) << " " << All_Mat(0, 1);
	return 0;
}

// FBGS应力标准化
int Stand_FBGS(QStringList &CH, mat &All_Mat, QStringList &XLabelName)
{
	QString CH1 = CH[0];
	QString CH2 = CH[1];
	QString CH3 = CH[2];
	QString CH4 = CH[3];
	QString CH5 = CH[4];
	QString CH6 = CH[5];
	QString CH7 = CH[6];

	// 时间
	//QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataName;

	// 由文件名输出mat、传感器ID编号、时间
	mat CH01_Mat = JIO::readCsv(CH1, DataName, XLabelName);
	mat CH02_Mat = JIO::readCsv(CH2, DataName, XLabelName2);
	mat CH03_Mat = JIO::readCsv(CH3, DataName, XLabelName2);
	mat CH04_Mat = JIO::readCsv(CH4, DataName, XLabelName2);
	mat CH05_Mat = JIO::readCsv(CH5, DataName, XLabelName2);
	mat CH06_Mat = JIO::readCsv(CH6, DataName, XLabelName2);
	mat CH07_Mat = JIO::readCsv(CH7, DataName, XLabelName2);

	// 矩阵合并
	All_Mat = join_rows(CH01_Mat.cols(0, 14), CH02_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH03_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH04_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH05_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH06_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH07_Mat.cols(0, 6));

	qDebug() << "FBG应力矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	qDebug() << "All_Mat(0,0)、All_Mat(0,0)：" << All_Mat(0, 0) << " " << All_Mat(0, 1);
	qDebug() << "CH01_Mat(0,0)、CH01_Mat(0,1)：" << CH01_Mat(0, 0) << " " << CH01_Mat(0, 1);
	return 0;
}

// FBGT温度标准化
int Stand_FBGT(QStringList &CH, mat &All_Mat, QStringList &XLabelName)
{
	QString CH08 = CH[0];
	QString CH09 = CH[1];
	QString CH10 = CH[2];
	QString CH11 = CH[3];
	QString CH12 = CH[4];
	QString CH13 = CH[5];
	QString CH14 = CH[6];
	QString CH15 = CH[7];
	QString CH16 = CH[8];
	QString CH17 = CH[9];
	QString CH18 = CH[10];
	QString CH19 = CH[11];
	QString CH20 = CH[12];
	QString CH21 = CH[13];
	QString CH22 = CH[14];
	QString CH23 = CH[15];
	QString CH24 = CH[16];
	QString CH25 = CH[17];
	QString CH26 = CH[18];
	QString CH27 = CH[19];
	QString CH28 = CH[20];
	QString CH29 = CH[21];
	QString CH30 = CH[22];
	QString CH31 = CH[23];
	QString CH32 = CH[24];

	// 时间
	//QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataName;

	// 由文件名输出mat、传感器ID编号、时间
	mat CH08_Mat = JIO::readCsv(CH08, DataName, XLabelName);
	mat CH09_Mat = JIO::readCsv(CH09, DataName, XLabelName2);
	mat CH10_Mat = JIO::readCsv(CH10, DataName, XLabelName2);
	mat CH11_Mat = JIO::readCsv(CH11, DataName, XLabelName2);
	mat CH12_Mat = JIO::readCsv(CH12, DataName, XLabelName2);
	mat CH13_Mat = JIO::readCsv(CH13, DataName, XLabelName2);
	mat CH14_Mat = JIO::readCsv(CH14, DataName, XLabelName2);
	mat CH15_Mat = JIO::readCsv(CH15, DataName, XLabelName2);
	mat CH16_Mat = JIO::readCsv(CH16, DataName, XLabelName2);
	mat CH17_Mat = JIO::readCsv(CH17, DataName, XLabelName2);
	mat CH18_Mat = JIO::readCsv(CH18, DataName, XLabelName2);
	mat CH19_Mat = JIO::readCsv(CH19, DataName, XLabelName2);
	mat CH20_Mat = JIO::readCsv(CH20, DataName, XLabelName2);
	mat CH21_Mat = JIO::readCsv(CH21, DataName, XLabelName2);
	mat CH22_Mat = JIO::readCsv(CH22, DataName, XLabelName2);
	mat CH23_Mat = JIO::readCsv(CH23, DataName, XLabelName2);
	mat CH24_Mat = JIO::readCsv(CH24, DataName, XLabelName2);
	mat CH25_Mat = JIO::readCsv(CH25, DataName, XLabelName2);
	mat CH26_Mat = JIO::readCsv(CH26, DataName, XLabelName2);
	mat CH27_Mat = JIO::readCsv(CH27, DataName, XLabelName2);
	mat CH28_Mat = JIO::readCsv(CH28, DataName, XLabelName2);
	mat CH29_Mat = JIO::readCsv(CH29, DataName, XLabelName2);
	mat CH30_Mat = JIO::readCsv(CH30, DataName, XLabelName2);
	mat CH31_Mat = JIO::readCsv(CH31, DataName, XLabelName2);
	mat CH32_Mat = JIO::readCsv(CH32, DataName, XLabelName2);

	// 矩阵合并
	All_Mat = join_rows(CH08_Mat.cols(0, 14), CH09_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH10_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH11_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH12_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH13_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH14_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH15_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH16_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH17_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH18_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH19_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH20_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH21_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH22_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH23_Mat.cols(0, 3));
	All_Mat = join_rows(All_Mat, CH24_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH25_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH26_Mat.cols(0, 3));
	All_Mat = join_rows(All_Mat, CH27_Mat.cols(0, 8));
	All_Mat = join_rows(All_Mat, CH28_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH29_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH30_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH31_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH32_Mat.cols(0, 2));

	qDebug() << "FBG应力矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	qDebug() << "All_Mat(0,0)、All_Mat(0,0)：" << All_Mat(0, 0) << " " << All_Mat(0, 1);
	qDebug() << "CH01_Mat(0,0)、CH01_Mat(0,1)：" << CH08_Mat(0, 0) << " " << CH08_Mat(0, 1);
	return 0;
}

// 将输入mat按标定波长进行修复
void MatStandWave(mat &CH_Mat, vector<double> &standWave)
{
	for (unsigned int i = 0; i < CH_Mat.n_rows; ++i)
	{
		vector<double> input;
		for (unsigned int j = 0; j < CH_Mat.n_cols; ++j)
		{
			input.push_back(CH_Mat(i, j));
		}
		double output[20] = { 0 };
		WaveFix(input, standWave, output);
		for (unsigned int j = 0; j < CH_Mat.n_cols; ++j)
		{
			CH_Mat(i, j) = output[j];
		}
	}
}

// FBGT温度标准化-修复波长版
int Stand_FBGT_Fix(QStringList &CH, mat &All_Mat, QStringList &XLabelName)
{
	QString CH08 = CH[0];
	QString CH09 = CH[1];
	QString CH10 = CH[2];
	QString CH11 = CH[3];
	QString CH12 = CH[4];
	QString CH13 = CH[5];
	QString CH14 = CH[6];
	QString CH15 = CH[7];
	QString CH16 = CH[8];
	QString CH17 = CH[9];
	QString CH18 = CH[10];
	QString CH19 = CH[11];
	QString CH20 = CH[12];
	QString CH21 = CH[13];
	QString CH22 = CH[14];
	QString CH23 = CH[15];
	QString CH24 = CH[16];
	QString CH25 = CH[17];
	QString CH26 = CH[18];
	QString CH27 = CH[19];
	QString CH28 = CH[20];
	QString CH29 = CH[21];
	QString CH30 = CH[22];
	QString CH31 = CH[23];
	QString CH32 = CH[24];

	// 时间
	//QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataName;

	// 由文件名输出mat、传感器ID编号、时间
	mat CH08_Mat = JIO::readCsv(CH08, DataName, XLabelName);
	mat CH09_Mat = JIO::readCsv(CH09, DataName, XLabelName2);
	mat CH10_Mat = JIO::readCsv(CH10, DataName, XLabelName2);
	mat CH11_Mat = JIO::readCsv(CH11, DataName, XLabelName2);
	mat CH12_Mat = JIO::readCsv(CH12, DataName, XLabelName2);
	mat CH13_Mat = JIO::readCsv(CH13, DataName, XLabelName2);
	mat CH14_Mat = JIO::readCsv(CH14, DataName, XLabelName2);
	mat CH15_Mat = JIO::readCsv(CH15, DataName, XLabelName2);
	mat CH16_Mat = JIO::readCsv(CH16, DataName, XLabelName2);
	mat CH17_Mat = JIO::readCsv(CH17, DataName, XLabelName2);
	mat CH18_Mat = JIO::readCsv(CH18, DataName, XLabelName2);
	mat CH19_Mat = JIO::readCsv(CH19, DataName, XLabelName2);
	mat CH20_Mat = JIO::readCsv(CH20, DataName, XLabelName2);
	mat CH21_Mat = JIO::readCsv(CH21, DataName, XLabelName2);
	mat CH22_Mat = JIO::readCsv(CH22, DataName, XLabelName2);
	mat CH23_Mat = JIO::readCsv(CH23, DataName, XLabelName2);
	mat CH24_Mat = JIO::readCsv(CH24, DataName, XLabelName2);
	mat CH25_Mat = JIO::readCsv(CH25, DataName, XLabelName2);
	mat CH26_Mat = JIO::readCsv(CH26, DataName, XLabelName2);
	mat CH27_Mat = JIO::readCsv(CH27, DataName, XLabelName2);
	mat CH28_Mat = JIO::readCsv(CH28, DataName, XLabelName2);
	mat CH29_Mat = JIO::readCsv(CH29, DataName, XLabelName2);
	mat CH30_Mat = JIO::readCsv(CH30, DataName, XLabelName2);
	mat CH31_Mat = JIO::readCsv(CH31, DataName, XLabelName2);
	mat CH32_Mat = JIO::readCsv(CH32, DataName, XLabelName2);

	QString newVersionTime = XLabelName.at(0).left(10);
	//	qDebug()<<"newVersionTime "<<newVersionTime;


	// 每项波长修复
	MatStandWave(CH08_Mat, standWave08);
	MatStandWave(CH09_Mat, standWave09);
	MatStandWave(CH10_Mat, standWave10);
	MatStandWave(CH11_Mat, standWave11);
	MatStandWave(CH12_Mat, standWave12);
	MatStandWave(CH13_Mat, standWave13);
	MatStandWave(CH14_Mat, standWave14);
	MatStandWave(CH15_Mat, standWave15);
	if (newVersionTime <= "2017-05-31")
	{
		// 老版本FBG这三个通道每个8传感器
		MatStandWave(CH16_Mat, standWave16);
		MatStandWave(CH17_Mat, standWave17);
		MatStandWave(CH18_Mat, standWave18);
	}
	else
	{
		// 2017-06-1日之后FBG这三个通道每个4传感器
		MatStandWave(CH16_Mat, standWave16_New170601);
		MatStandWave(CH17_Mat, standWave17_New170601);
		MatStandWave(CH18_Mat, standWave18_New170601);
	}
	MatStandWave(CH19_Mat, standWave19);
	MatStandWave(CH20_Mat, standWave20);
	MatStandWave(CH21_Mat, standWave21);
	MatStandWave(CH22_Mat, standWave22);
	MatStandWave(CH23_Mat, standWave23);
	MatStandWave(CH24_Mat, standWave24);
	MatStandWave(CH25_Mat, standWave25);
	MatStandWave(CH26_Mat, standWave26);
	MatStandWave(CH27_Mat, standWave27);
	MatStandWave(CH28_Mat, standWave28);
	MatStandWave(CH29_Mat, standWave29);
	MatStandWave(CH30_Mat, standWave30);
	MatStandWave(CH31_Mat, standWave31);
	MatStandWave(CH32_Mat, standWave32);

	// 矩阵合并
	All_Mat = join_rows(CH08_Mat.cols(0, 14), CH09_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH10_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH11_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH12_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH13_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH14_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH15_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH16_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH17_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH18_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH19_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH20_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH21_Mat.cols(0, 6));
	All_Mat = join_rows(All_Mat, CH22_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH23_Mat.cols(0, 3));
	All_Mat = join_rows(All_Mat, CH24_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH25_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH26_Mat.cols(0, 3));
	All_Mat = join_rows(All_Mat, CH27_Mat.cols(0, 8));
	All_Mat = join_rows(All_Mat, CH28_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH29_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH30_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH31_Mat.cols(0, 9));
	All_Mat = join_rows(All_Mat, CH32_Mat.cols(0, 2));

	// 某一列遇到0值用前一行值覆盖
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < All_Mat.n_rows; ++i) // 从第二行开始处理
		{
			if (All_Mat(i, j) < 0.001 && All_Mat(i - 1, j) > 0.001)
			{
				// 如果某一列现在值为0，且上一行对应值不为0，上一行值给这一行
				All_Mat(i, j) = All_Mat(i - 1, j);
			}
		}
	}
	// 倒序来一轮，防止前面很多行都是0，靠后面的把前面的补全了
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (int i = All_Mat.n_rows - 2; i >= 0; --i) // 从倒数第二行开始处理, 并且要处理0行，递减只好用有符号(这种做法不好)
		{
			if (All_Mat(i, j) < 0.001 && All_Mat(i + 1, j) > 0.001)
			{
				All_Mat(i, j) = All_Mat(i + 1, j);
			}
		}
	}
	// 来一轮前后差值的，滤除突变点
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < All_Mat.n_rows; ++i) // 从第二行开始处理
		{
			if (fabs(All_Mat(i, j) - All_Mat(i - 1, j)) > 0.01575) // 前后波动1.5度以上说明是突变点
			{
				All_Mat(i, j) = All_Mat(i - 1, j);
			}
		}
	}

	qDebug() << "FBG温度矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	qDebug() << "All_Mat(0,0)、All_Mat(0,0)：" << All_Mat(0, 0) << " " << All_Mat(0, 1);
	qDebug() << "CH01_Mat(0,0)、CH01_Mat(0,1)：" << CH08_Mat(0, 0) << " " << CH08_Mat(0, 1);
	return 0;
}

// FBGS应力标准化-修复波长版
int Stand_FBGS_Fix(QStringList &CH, mat &All_Mat, QStringList &XLabelName)
{
	QString CH1 = CH[0];
	QString CH2 = CH[1];
	QString CH3 = CH[2];
	QString CH4 = CH[3];
	QString CH5 = CH[4];
	QString CH6 = CH[5];
	QString CH7 = CH[6];

	// 时间
	//QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataName;

	// 由文件名输出mat、传感器ID编号、时间
	mat CH01_Mat = JIO::readCsv(CH1, DataName, XLabelName);
	mat CH02_Mat = JIO::readCsv(CH2, DataName, XLabelName2);
	mat CH03_Mat = JIO::readCsv(CH3, DataName, XLabelName2);
	mat CH04_Mat = JIO::readCsv(CH4, DataName, XLabelName2);
	mat CH05_Mat = JIO::readCsv(CH5, DataName, XLabelName2);
	mat CH06_Mat = JIO::readCsv(CH6, DataName, XLabelName2);
	mat CH07_Mat = JIO::readCsv(CH7, DataName, XLabelName2);

	// 每项波长修复
	MatStandWave(CH01_Mat, standWave01);
	MatStandWave(CH02_Mat, standWave02);
	MatStandWave(CH03_Mat, standWave03);
	MatStandWave(CH04_Mat, standWave04);
	MatStandWave(CH05_Mat, standWave05);
	MatStandWave(CH06_Mat, standWave06);
	MatStandWave(CH07_Mat, standWave07);

	// 矩阵合并
	All_Mat = join_rows(CH01_Mat.cols(0, 14), CH02_Mat.cols(0, 7));
	All_Mat = join_rows(All_Mat, CH03_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH04_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH05_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH06_Mat.cols(0, 14));
	All_Mat = join_rows(All_Mat, CH07_Mat.cols(0, 6));

	// 某一列遇到0值用前一行值覆盖
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < All_Mat.n_rows; ++i) // 从第二行开始处理
		{
			if (All_Mat(i, j) < 0.001 && All_Mat(i - 1, j) > 0.001)
			{
				// 如果某一列现在值为0，且上一行对应值不为0，上一行值给这一行
				All_Mat(i, j) = All_Mat(i - 1, j);
			}
		}
	}
	// 倒序来一轮，防止前面很多行都是0，靠后面的把前面的补全了
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (int i = All_Mat.n_rows - 2; i >= 0; --i) // 从倒数第二行开始处理, 并且要处理0行，递减只好用有符号(这种做法不好)
		{
			if (All_Mat(i, j) < 0.001 && All_Mat(i + 1, j) > 0.001)
			{
				All_Mat(i, j) = All_Mat(i + 1, j);
			}
		}
	}
	// 来一轮前后差值的，滤除突变点
	for (unsigned int j = 0; j < All_Mat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < All_Mat.n_rows; ++i) // 从第二行开始处理
		{
			if (fabs(All_Mat(i, j) - All_Mat(i - 1, j)) > 0.01575) // 前后波动1.5度以上说明是突变点
			{
				All_Mat(i, j) = All_Mat(i - 1, j);
			}
		}
	}

	qDebug() << "FBG应力矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	qDebug() << "All_Mat(0,0)、All_Mat(0,0)：" << All_Mat(0, 0) << " " << All_Mat(0, 1);
	qDebug() << "CH01_Mat(0,0)、CH01_Mat(0,1)：" << CH01_Mat(0, 0) << " " << CH01_Mat(0, 1);
	return 0;
}

// 波长转温度算法-T=k(wave-Bwave)+Btemp
mat FBGtoTEMP(QString &standFBGFileName, QStringList &XLabelName)
{
	QStringList DataName;
	mat FBGWave = JIO::readCsv(standFBGFileName, DataName, XLabelName);
	// 当前文件名
	QString currentFileName = standFBGFileName.right(standFBGFileName.size() - standFBGFileName.lastIndexOf('/') - 1);
	// 日期
	QString newVersionTime = currentFileName.left(10);
	qDebug() << "newVersionTime " << newVersionTime;
	if (newVersionTime <= "2017-05-31")
	{
		for (unsigned int i = 0; i < FBGWave.n_rows; i++)
		{
			for (unsigned int j = 0; j < FBGWave.n_cols; j++)
			{
				FBGWave(i, j) = (FBGWave(i, j) - WaveAndTemp[j][1]) / 0.0105 + WaveAndTemp[j][0];
			}
		}
	}
	else
	{
		for (unsigned int i = 0; i < FBGWave.n_rows; i++)
		{
			for (unsigned int j = 0; j < FBGWave.n_cols; j++)
			{
				FBGWave(i, j) = (FBGWave(i, j) - calibrationWave[j]) / 0.0105;
			}
		}
	}

	return FBGWave;
}

// FBG汇总为一个mat
mat Stand_FBG(QStringList &CH)
{
	QString CH1 = CH[0];
	QString CH2 = CH[1];
	QString CH3 = CH[2];
	QString CH4 = CH[3];
	QString CH5 = CH[4];
	QString CH6 = CH[5];
	QString CH7 = CH[6];
	QString CH08 = CH[7];
	QString CH09 = CH[8];
	QString CH10 = CH[9];
	QString CH11 = CH[10];
	QString CH12 = CH[11];
	QString CH13 = CH[12];
	QString CH14 = CH[13];
	QString CH15 = CH[14];
	QString CH16 = CH[15];
	QString CH17 = CH[16];
	QString CH18 = CH[17];
	QString CH19 = CH[18];
	QString CH20 = CH[19];
	QString CH21 = CH[20];
	QString CH22 = CH[21];
	QString CH23 = CH[22];
	QString CH24 = CH[23];
	QString CH25 = CH[24];
	QString CH26 = CH[25];
	QString CH27 = CH[26];
	QString CH28 = CH[27];
	QString CH29 = CH[28];
	QString CH30 = CH[29];
	QString CH31 = CH[30];
	QString CH32 = CH[31];

	// 时间
	QStringList XLabelName;
	QStringList XLabelName2;

	// 传感器ID编号
	QStringList DataName;

	// 由文件名输出mat、传感器ID编号、时间
	mat CH01_Mat = JIO::readCsv(CH1, DataName, XLabelName);
	mat CH02_Mat = JIO::readCsv(CH2, DataName, XLabelName2);
	mat CH03_Mat = JIO::readCsv(CH3, DataName, XLabelName2);
	mat CH04_Mat = JIO::readCsv(CH4, DataName, XLabelName2);
	mat CH05_Mat = JIO::readCsv(CH5, DataName, XLabelName2);
	mat CH06_Mat = JIO::readCsv(CH6, DataName, XLabelName2);
	mat CH07_Mat = JIO::readCsv(CH7, DataName, XLabelName2);
	mat CH08_Mat = JIO::readCsv(CH08, DataName, XLabelName);
	mat CH09_Mat = JIO::readCsv(CH09, DataName, XLabelName2);
	mat CH10_Mat = JIO::readCsv(CH10, DataName, XLabelName2);
	mat CH11_Mat = JIO::readCsv(CH11, DataName, XLabelName2);
	mat CH12_Mat = JIO::readCsv(CH12, DataName, XLabelName2);
	mat CH13_Mat = JIO::readCsv(CH13, DataName, XLabelName2);
	mat CH14_Mat = JIO::readCsv(CH14, DataName, XLabelName2);
	mat CH15_Mat = JIO::readCsv(CH15, DataName, XLabelName2);
	mat CH16_Mat = JIO::readCsv(CH16, DataName, XLabelName2);
	mat CH17_Mat = JIO::readCsv(CH17, DataName, XLabelName2);
	mat CH18_Mat = JIO::readCsv(CH18, DataName, XLabelName2);
	mat CH19_Mat = JIO::readCsv(CH19, DataName, XLabelName2);
	mat CH20_Mat = JIO::readCsv(CH20, DataName, XLabelName2);
	mat CH21_Mat = JIO::readCsv(CH21, DataName, XLabelName2);
	mat CH22_Mat = JIO::readCsv(CH22, DataName, XLabelName2);
	mat CH23_Mat = JIO::readCsv(CH23, DataName, XLabelName2);
	mat CH24_Mat = JIO::readCsv(CH24, DataName, XLabelName2);
	mat CH25_Mat = JIO::readCsv(CH25, DataName, XLabelName2);
	mat CH26_Mat = JIO::readCsv(CH26, DataName, XLabelName2);
	mat CH27_Mat = JIO::readCsv(CH27, DataName, XLabelName2);
	mat CH28_Mat = JIO::readCsv(CH28, DataName, XLabelName2);
	mat CH29_Mat = JIO::readCsv(CH29, DataName, XLabelName2);
	mat CH30_Mat = JIO::readCsv(CH30, DataName, XLabelName2);
	mat CH31_Mat = JIO::readCsv(CH31, DataName, XLabelName2);
	mat CH32_Mat = JIO::readCsv(CH32, DataName, XLabelName2);

	// 矩阵合并
	mat All_Mat;
	All_Mat = join_rows(CH01_Mat, CH02_Mat);
	All_Mat = join_rows(All_Mat, CH03_Mat);
	All_Mat = join_rows(All_Mat, CH04_Mat);
	All_Mat = join_rows(All_Mat, CH05_Mat);
	All_Mat = join_rows(All_Mat, CH06_Mat);
	All_Mat = join_rows(All_Mat, CH07_Mat);
	All_Mat = join_rows(All_Mat, CH08_Mat);
	All_Mat = join_rows(All_Mat, CH09_Mat);
	All_Mat = join_rows(All_Mat, CH10_Mat);
	All_Mat = join_rows(All_Mat, CH11_Mat);
	All_Mat = join_rows(All_Mat, CH12_Mat);
	All_Mat = join_rows(All_Mat, CH13_Mat);
	All_Mat = join_rows(All_Mat, CH14_Mat);
	All_Mat = join_rows(All_Mat, CH15_Mat);
	All_Mat = join_rows(All_Mat, CH16_Mat);
	All_Mat = join_rows(All_Mat, CH17_Mat);
	All_Mat = join_rows(All_Mat, CH18_Mat);
	All_Mat = join_rows(All_Mat, CH19_Mat);
	All_Mat = join_rows(All_Mat, CH20_Mat);
	All_Mat = join_rows(All_Mat, CH21_Mat);
	All_Mat = join_rows(All_Mat, CH22_Mat);
	All_Mat = join_rows(All_Mat, CH23_Mat);
	All_Mat = join_rows(All_Mat, CH24_Mat);
	All_Mat = join_rows(All_Mat, CH25_Mat);
	All_Mat = join_rows(All_Mat, CH26_Mat);
	All_Mat = join_rows(All_Mat, CH27_Mat);
	All_Mat = join_rows(All_Mat, CH28_Mat);
	All_Mat = join_rows(All_Mat, CH29_Mat);
	All_Mat = join_rows(All_Mat, CH30_Mat);
	All_Mat = join_rows(All_Mat, CH31_Mat);
	All_Mat = join_rows(All_Mat, CH32_Mat);

	qDebug() << "FBG矩阵行列：" << All_Mat.n_rows << " " << All_Mat.n_cols;
	//	qDebug()<<"All_Mat(0,0)、All_Mat(0,0)："<<All_Mat(0,0)<<" "<<All_Mat(0,1);
	//	qDebug()<<"CH01_Mat(0,0)、CH01_Mat(0,1)："<<CH01_Mat(0,0)<<" "<<CH01_Mat(0,1);
	return All_Mat;
}

// 将640个FBG通道转为我们需要的321个通道，包括应力、温度
bool ALLFBGto321FBG(mat &inputMat, mat &outputMat)
{
	// inputMat按通道分给不同的小mat
	mat CH01_Mat = inputMat.cols(0, 19);
	mat CH02_Mat = inputMat.cols(20, 39);
	mat CH03_Mat = inputMat.cols(40, 59);
	mat CH04_Mat = inputMat.cols(60, 79);
	mat CH05_Mat = inputMat.cols(80, 99);
	mat CH06_Mat = inputMat.cols(100, 119);
	mat CH07_Mat = inputMat.cols(120, 139);
	mat CH08_Mat = inputMat.cols(140, 159);
	mat CH09_Mat = inputMat.cols(160, 179);
	mat CH10_Mat = inputMat.cols(180, 199);
	mat CH11_Mat = inputMat.cols(200, 219);
	mat CH12_Mat = inputMat.cols(220, 239);
	mat CH13_Mat = inputMat.cols(240, 259);
	mat CH14_Mat = inputMat.cols(260, 279);
	mat CH15_Mat = inputMat.cols(280, 299);
	mat CH16_Mat = inputMat.cols(300, 319);
	mat CH17_Mat = inputMat.cols(320, 339);
	mat CH18_Mat = inputMat.cols(340, 359);
	mat CH19_Mat = inputMat.cols(360, 379);
	mat CH20_Mat = inputMat.cols(380, 399);
	mat CH21_Mat = inputMat.cols(400, 419);
	mat CH22_Mat = inputMat.cols(420, 439);
	mat CH23_Mat = inputMat.cols(440, 459);
	mat CH24_Mat = inputMat.cols(460, 479);
	mat CH25_Mat = inputMat.cols(480, 499);
	mat CH26_Mat = inputMat.cols(500, 519);
	mat CH27_Mat = inputMat.cols(520, 539);
	mat CH28_Mat = inputMat.cols(540, 559);
	mat CH29_Mat = inputMat.cols(560, 579);
	mat CH30_Mat = inputMat.cols(580, 599);
	mat CH31_Mat = inputMat.cols(600, 619);
	mat CH32_Mat = inputMat.cols(620, 639);

	// 每项波长修复
	MatStandWave(CH01_Mat, standWave01);
	MatStandWave(CH02_Mat, standWave02);
	MatStandWave(CH03_Mat, standWave03);
	MatStandWave(CH04_Mat, standWave04);
	MatStandWave(CH05_Mat, standWave05);
	MatStandWave(CH06_Mat, standWave06);
	MatStandWave(CH07_Mat, standWave07);
	MatStandWave(CH08_Mat, standWave08);
	MatStandWave(CH09_Mat, standWave09);
	MatStandWave(CH10_Mat, standWave10);
	MatStandWave(CH11_Mat, standWave11);
	MatStandWave(CH12_Mat, standWave12);
	MatStandWave(CH13_Mat, standWave13);
	MatStandWave(CH14_Mat, standWave14);
	MatStandWave(CH15_Mat, standWave15);
	MatStandWave(CH16_Mat, standWave16_New170601);
	MatStandWave(CH17_Mat, standWave17_New170601);
	MatStandWave(CH18_Mat, standWave18_New170601);
	MatStandWave(CH19_Mat, standWave19);
	MatStandWave(CH20_Mat, standWave20);
	MatStandWave(CH21_Mat, standWave21);
	MatStandWave(CH22_Mat, standWave22);
	MatStandWave(CH23_Mat, standWave23);
	MatStandWave(CH24_Mat, standWave24);
	MatStandWave(CH25_Mat, standWave25);
	MatStandWave(CH26_Mat, standWave26);
	MatStandWave(CH27_Mat, standWave27);
	MatStandWave(CH28_Mat, standWave28);
	MatStandWave(CH29_Mat, standWave29);
	MatStandWave(CH30_Mat, standWave30);
	MatStandWave(CH31_Mat, standWave31);
	MatStandWave(CH32_Mat, standWave32);

	// 矩阵合并
	outputMat = join_rows(CH01_Mat.cols(0, 14), CH02_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH03_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH04_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH05_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH06_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH07_Mat.cols(0, 6));
	outputMat = join_rows(outputMat, CH08_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH09_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH10_Mat.cols(0, 6));
	outputMat = join_rows(outputMat, CH11_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH12_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH13_Mat.cols(0, 14));
	outputMat = join_rows(outputMat, CH14_Mat.cols(0, 6));
	outputMat = join_rows(outputMat, CH15_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH16_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH17_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH18_Mat.cols(0, 7));
	outputMat = join_rows(outputMat, CH19_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH20_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH21_Mat.cols(0, 6));
	outputMat = join_rows(outputMat, CH22_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH23_Mat.cols(0, 3));
	outputMat = join_rows(outputMat, CH24_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH25_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH26_Mat.cols(0, 3));
	outputMat = join_rows(outputMat, CH27_Mat.cols(0, 8));
	outputMat = join_rows(outputMat, CH28_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH29_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH30_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH31_Mat.cols(0, 9));
	outputMat = join_rows(outputMat, CH32_Mat.cols(0, 2));

	// 某一列遇到0值用前一行值覆盖
	for (unsigned int j = 0; j < outputMat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < outputMat.n_rows; ++i) // 从第二行开始处理
		{
			if (outputMat(i, j) < 0.001 && outputMat(i - 1, j) > 0.001)
			{
				// 如果某一列现在值为0，且上一行对应值不为0，上一行值给这一行
				outputMat(i, j) = outputMat(i - 1, j);
			}
		}
	}
	// 倒序来一轮，防止前面很多行都是0，靠后面的把前面的补全了
	for (unsigned int j = 0; j < outputMat.n_cols; ++j) // 先对列处理
	{
		for (int i = outputMat.n_rows - 2; i >= 0; --i) // 从倒数第二行开始处理, 并且要处理0行，递减只好用有符号(这种做法不好)
		{
			if (outputMat(i, j) < 0.001 && outputMat(i + 1, j) > 0.001)
			{
				outputMat(i, j) = outputMat(i + 1, j);
			}
		}
	}
	// 来一轮前后差值的，滤除突变点
	for (unsigned int j = 0; j < outputMat.n_cols; ++j) // 先对列处理
	{
		for (unsigned int i = 1; i < outputMat.n_rows; ++i) // 从第二行开始处理
		{
			if (fabs(outputMat(i, j) - outputMat(i - 1, j)) > 0.01575) // 前后波动1.5度以上说明是突变点
			{
				outputMat(i, j) = outputMat(i - 1, j);
			}
		}
	}

	qDebug() << "FBG矩阵行列：" << outputMat.n_rows << " " << outputMat.n_cols;
	qDebug() << "outputMat(0,0)、outputMat(0,0)：" << outputMat(0, 0) << " " << outputMat(0, 1);
	qDebug() << "CH01_Mat(0,0)、CH01_Mat(0,1)：" << CH01_Mat(0, 0) << " " << CH01_Mat(0, 1);
	return true;
}

// 保存标准数据-时间修复
bool saveStandData(QString Title, QString DataName, QStringList Time, mat Mat)
{
	QString Text = Title + "," + DataName + "\r\n";
	// 写抬头
	QString SaveFileName = saveFilePath + Time[0].left(10) + Title + ".csv";
	QFile file(SaveFileName); // 实例 QFile
	file.open(QIODevice::ReadWrite | QIODevice::Append); // 存在打开，不存在创建
	QByteArray str = Text.toUtf8();// 写入内容，这里需要转码，否则报错。
	file.write(str); // 写入内容,这里需要转码，否则报错。
					 // 写数据
	Text = "";
	for (unsigned int i = 0; i < Mat.n_rows; i++)
	{
		QString MatRowStr;
		for (unsigned int j = 0; j < Mat.n_cols; j++)
		{
			QString value;
			value.sprintf("%.3lf", Mat(i, j));
			if (j != Mat.n_cols - 1) MatRowStr = MatRowStr + value + ",";
			else MatRowStr = MatRowStr + value + "\r\n";
		}
		Text = Time[i].right(8) + "," + MatRowStr;// 时间【切出】时分秒
		str = Text.toUtf8();
		file.write(str);
	}
	file.close();
	return true;
}

// 保存标准数据-时间不修复
bool saveStandDataNoTimeFix(QString Title, QString DataName, QString Date, QStringList Time, mat Mat)
{
	QString Text = Title + "," + DataName + "\r\n";
	// 写抬头
	QString SaveFileName = saveFilePath + Date + Title + ".csv";
	QFile file(SaveFileName); // 实例 QFile
	file.open(QIODevice::ReadWrite | QIODevice::Append); // 存在打开，不存在创建
	QByteArray str = Text.toUtf8();// 写入内容，这里需要转码，否则报错。
	file.write(str); // 写入内容,这里需要转码，否则报错。
					 // 写数据
	Text = "";
	for (unsigned int i = 0; i < Mat.n_rows; i++)
	{
		QString MatRowStr;
		for (unsigned int j = 0; j < Mat.n_cols; j++)
		{
			QString value;
			value.sprintf("%.3lf", Mat(i, j));
			if (j != Mat.n_cols - 1) MatRowStr = MatRowStr + value + ",";
			else MatRowStr = MatRowStr + value + "\r\n";
		}
		Text = Time[i] + "," + MatRowStr;// 时间【就是】时分秒
		str = Text.toUtf8();
		file.write(str);
	}
	file.close();
	return true;
}

// 相关性分析，得到相关性矩阵
mat CorrelationAnalysis(const QString &correlationFileName1, const QString &correlationFileName2, QStringList &DataName1, QStringList &DataName2, QStringList &Time)
{
	// 读取两文件矩阵
	mat File1 = JIO::readCsv(correlationFileName1, DataName1, Time);
	mat File2 = JIO::readCsv(correlationFileName2, DataName2, Time);
	//    qDebug()<<"File1(0,0)"<<File1(0,0);
	//    qDebug()<<"File2(0,0)"<<File2(0,0);

	// 矩阵合并
	mat All_Mat = join_rows(File1, File2);

	// 相关系数
	// 求矩阵A与B的相关系数矩阵。矩阵A(B)的每一列为一个变量，每一行为一组观测值。矩阵C(i,j)表示矩阵A的第i个变量与矩阵B的第j个变量的相关系数。
	mat corMat = cor(All_Mat);
	// 真正需要的相关系数
	mat corMatneed(File1.n_cols, File2.n_cols);
	for (unsigned int i = 0; i < corMatneed.n_rows; i++)
	{
		for (unsigned int j = 0; j < corMatneed.n_cols; j++)
		{
			corMatneed(i, j) = corMat(i, j + File1.n_cols);
		}
	}
	return corMatneed;
}

// 保存相关性分析的结果
bool saveCorrelationAnalysisCSV(const QString &correlationFileName1, const QString &correlationFileName2, QStringList &DataName1, QStringList &DataName2, mat &corMatneed)
{
	// 构造DataName2str 数据编号 列为数据1编号  行为数据2编号
	QString DataName2str;
	for (int i = 0; i < DataName2.size(); i++)
	{
		if (i == DataName2.size() - 1)
			DataName2str = DataName2str + DataName2[i];
		else
			DataName2str = DataName2str + DataName2[i] + ",";
	}
	// 提取Date、vs内容字符串
	QStringList Name0List = correlationFileName1.split("/");
	QStringList Name1List = correlationFileName1.split("-");
	QStringList Name2List = correlationFileName2.split("-");
	QStringList Name12List = Name1List[3].split(".");
	QStringList Name22List = Name2List[3].split(".");
	QString Title = "Correlation-" + Name12List[0] + "vs" + Name22List[0];
	QString Date = Name0List[Name0List.size() - 1].left(10);
	//    qDebug()<< "Date "<<Date;
	//    qDebug()<< "correlationFileName1 "<<correlationFileName1;
	//    qDebug()<< "Title "<<Title;
	int b = saveStandDataNoTimeFix(Title, DataName2str, Date, DataName1, corMatneed);
	if (b == 0)
		return true;
	else
		return false;
}

// 寻找行
int JfzFileReadRow(QString FileName)
{
	int RowNum = 0;
	QFile f(FileName);
	if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
	{
		return -1;
	}
	QTextStream txtInput(&f);
	QString lineStr;
	while (!txtInput.atEnd())
	{
		txtInput.readLine();
		RowNum++;
	}
	f.close();
	return RowNum;
}

// 寻找列
int JfzFileReadCol(QString FileName)
{
	int ColNum = 0;
	QFile f(FileName);
	if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
	{
		return -1;
	}
	QTextStream txtInput(&f);
	QString lineStr = txtInput.readLine();
	QStringList tempbar = lineStr.split(",");
	ColNum = tempbar.size();
	f.close();
	return ColNum;
}

// 数据分析-处理核心
mat DataAnalysis(QString &InputFileName_str, QStringList &DataName, QString &strMatRow, QString &strMatCol, QString &strTitle, QString &strMatSum, QString &strMatArithmeticMean, QString &strMatMax, QString &strMatMin)
{
	// 需要的数据的定义
	int InputFileRow = 0; // 文件行
	int InputFileCol = 0; // 文件列
	QString Title; // 文件内容名字（表名字）
	QStringList XLabelName; // X标签名

							// 读取文件内容
	QFile f(InputFileName_str);
	if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) {}
	QTextStream txtInput(&f);
	// 读第一行,得到[标题],[数据各项名]
	QString lineStr = txtInput.readLine();
	QStringList tempbar = lineStr.split(",");
	Title = tempbar[0];
	// 读切片个数即为[列数]
	InputFileCol = tempbar.size();
	for (int i = 1; i < tempbar.size(); i++)
	{
		DataName.append(tempbar[i]);// [数据各项名]
	}

	InputFileRow = JfzFileReadRow(InputFileName_str); // [行数]
	mat Mat(InputFileRow - 1, InputFileCol - 1); // 存数据的矩阵，少一行一列

	int Row = 0; // 行编号
	while (!txtInput.atEnd())
	{
		lineStr = txtInput.readLine();
		tempbar = lineStr.split(",");
		XLabelName.append(tempbar[0]);// 添加[X标签名]
		for (int i = 1; i < tempbar.size(); i++)
		{
			Mat(Row, i - 1) = tempbar[i].toDouble();
		}
		Row++;
	}
	f.close();

	// Debug信息
	qDebug() << "Armadillo 版本: " << QString::fromStdString(arma_version::as_string());
	//    qDebug()<< "行" << InputFileRow << "列" << InputFileCol;
	//    qDebug()<< "标题" << Title;
	//    qDebug()<< "数据各项名" << DataName;
	//    qDebug()<< "X标签名" << XLabelName;

	// 保存输入Mat,预留
	//    Mat.save("Mat.txt", raw_ascii);
	//    qDebug()<< "Mat行" << Mat.n_rows << "Mat列" << Mat.n_cols;
	//    qDebug()<< "矩阵的最大值max(max(Mat)) = " << max(max(Mat));
	//    qDebug()<< "矩阵的最小值min(min(Mat)) = " << min(min(Mat));
	//    qDebug()<< "所有元素的和accu(Mat): " << accu(Mat);
	//    qDebug()<< "平均值: " << (accu(Mat))/(Mat.n_rows * Mat.n_cols);

	// 与矩阵计算相关的定义
	int MatRow = Mat.n_rows;
	int MatCol = Mat.n_cols;
	double MatMax = max(max(Mat));
	double MatMin = min(min(Mat));
	double MatSum = accu(Mat);
	double MatArithmeticMean = (accu(Mat)) / (Mat.n_rows * Mat.n_cols);

	// 数据概览-输出
	strMatRow = QString::number(MatRow);
	strMatCol = QString::number(MatCol);
	strTitle = Title;
	strMatSum = QString::number(MatSum);
	strMatArithmeticMean = QString::number(MatArithmeticMean);
	strMatMax = QString::number(MatMax);
	strMatMin = QString::number(MatMin);

	return Mat;
}

// 数据分析-诊断
bool DataDiagnosis(QString &InputFileName_str, mat &Mat, QStringList &DataName)
{
	qDebug() << "【文件名】" + getFileName(InputFileName_str);

	// 数据基本信息-处理
	mat colMat = sum(Mat); // 每一列的总和
	mat maxMat = max(Mat); // 每一列的最大值
	mat minMat = min(Mat); // 每一列的最大值

	for (unsigned int i = 0; i < Mat.n_cols; i++)
	{
		QString text;
		float avg = colMat(i)*1.0 / (Mat.n_rows); // 算术平均值
		string strDataName(DataName[i].toStdString());
		text.sprintf("%s  和:%-15.4f  最大值:%-15.4f  最小值:%-15.4f  算术平均值:%-15.4f", strDataName.c_str(), colMat(i), maxMat(i), minMat(i), avg);

		qDebug() << avg;
		if (InputFileName_str.right(6).left(2) == "20" || InputFileName_str.right(6).left(2) == "MP") // 电类和转好的FBG温度判断
		{
			if (maxMat(i) - minMat(i) < 15 && avg > 0 && avg < 50)
				qDebug() << text;
			else
			{
				if (fabs(avg) < 0.00001)
				{
					QString text2 = text.replace(QRegExp("\\ "), "&nbsp;");
					qDebug() << text2 + "<span style='color:blue'>数据没有</span>";// 标蓝
				}
				else
				{
					QString text2 = text.replace(QRegExp("\\ "), "&nbsp;");
					qDebug() << text2 + "<span style='color:red'>数据异常</span>";// 标红
				}
			}
		}
		else if (InputFileName_str.right(6).left(2) == "ss" || InputFileName_str.right(6).left(2) == "re") // FBG波长数据判断
		{
			if (maxMat(i) - minMat(i) < 3 && avg != 0)
				qDebug() << text;
			else
			{
				if (fabs(avg) < 0.00001)
				{
					QString text2 = text.replace(QRegExp("\\ "), "&nbsp;");
					qDebug() << text2 + "<span style='color:blue'>数据没有</span>";// 标蓝
				}
				else
				{
					QString text2 = text.replace(QRegExp("\\ "), "&nbsp;");
					qDebug() << text2 + "<span style='color:red'>数据异常</span>";// 标红
				}
			}
		}
		else if (InputFileName_str.right(6).left(2) == "CD") // CCD数据判断
		{
			//qDebug()<<"fabs(avg)"<<fabs(avg);
			if (fabs(avg) < 0.2)
				qDebug() << text;
			else
			{
				QString text2 = text.replace(QRegExp("\\ "), "&nbsp;");
				qDebug() << text2 + "<span style='color:red'>偏移过大</span>";// 标红
			}
		}
		else // 没有特殊说明，不诊断直接显示
		{
			qDebug() << text;
		}

	}
	// 数据基本信息-求相关系数
	// 求矩阵A与B的相关系数矩阵。矩阵A(B)的每一列为一个变量，每一行为一组观测值。矩阵C(i,j)表示矩阵A的第i个变量与矩阵B的第j个变量的相关系数。
	//        mat corMat = cor(Mat);
	//        //        qDebug()<< corMat.n_rows<<" "<< corMat.n_cols;
	//        QString corStr = "";
	//        ui->textEdit->append("\n每列数据间相关系数：");
	//        for(unsigned int i=0; i< corMat.n_rows ; i++)
	//        {
	//            for(unsigned int j=0; j< corMat.n_cols ; j++)
	//            {
	//                QString standStr;
	//                standStr.sprintf("%8.4f", corMat(i,j));
	//                corStr += standStr + " ";
	//            }
	//            ui->textEdit->append(corStr);
	//            corStr = "";
	//        }
	//        qDebug()<< "poi";
	return true;
}

// 抽样取点函数
QList<int> sampling(int nowNum, int needNum)
{
	QList<int> outQList;
	// 压缩
	if (nowNum >= needNum)
	{
		double bilv = needNum*1.0 / nowNum;
		double *data = new double[nowNum];
		for (int i = 0; i < nowNum; ++i)
		{
			data[i] = floor(i*bilv);
		}

		int value = -1;
		for (int i = 0; i < nowNum; ++i)
		{
			if (data[i] != value)
			{
				outQList.append(i);
				value = data[i];
			}
		}
		delete[] data;
	}
	// 拉伸
	if (nowNum < needNum)
	{
		double bilv = nowNum*1.0 / needNum;
		double *data = new double[needNum];
		for (int i = 0; i < needNum; ++i)
		{
			data[i] = floor(i*bilv);
			outQList.append(data[i]);
		}
		delete[] data;
	}

	return outQList;
}

// 功能: 按窗口大小寻找某一序列的 最大值\最小值\平均值 集合  参数: 输入向量, 窗口大小, 输出最大值向量, 输出最小值向量
bool findTrendByWindow(QList<double> &input, int window, QList<double> &outMax, QList<double> &outMin, QList<double> &outAvg)
{
	double max = -100000000;
	double min = 100000000;
	double sum = 0;
	for (int i = 0; i < input.size(); i = i + window)
	{
		int cnt = 0;
		for (int j = 0; j < window; j++)
		{
			if ((i + j) >= input.size())
			{
				cnt = j;
				break;
			}
			if (input[i + j] > max) max = input[i + j];
			if (input[i + j] < min) min = input[i + j];
			sum += input[i + j];
			cnt = j + 1;
		}
		outMax.append(max);
		outMin.append(min);
		outAvg.append(sum / cnt);
		//cout<<max<<" ";
		//cout<<min<<" ";
		max = -100000000;
		min = 100000000;
		sum = 0;
	}
	return true;
}

/********************3、【数据标准化对外接口】********************/

// 数据标准化-DS18B20-部署通道排序
bool standardDS18B20(QString dir)
{
	// 【1】获取CH通道对应文件
	QStringList CH = get_DS18B20_csv(dir);
	// 【2】数据标准化
	QStringList Time;
	mat MatDS18B20;
	Stand_DS18B20(CH, MatDS18B20, Time);// 各通道数据转Mat并排序
	// 【3】保存文件
	bool b = saveStandData("Data-DS18B20", DataName_DS18B20, Time, MatDS18B20);
	return b;
}

// 数据标准化-CCD-部署通道排序
bool standardCCD(QString dir)
{
	// 【1】获取CH通道对应文件
	QStringList CH = get_CCD_csv(dir);
	// 【2】数据标准化
	QStringList Time;
	mat MatCCD;
	Stand_CCD(CH, MatCCD, Time);
	// 【3】保存文件
	bool b = saveStandData("Data-CCD", DataName_CCD, Time, MatCCD);
	return b;
}

// 数据标准化-FBGT(预处理-波长修复)-部署通道排序
bool standardFBGT(QString dir)
{
	// 【1】获取CH通道对应文件
	QStringList CH = get_FBGT_csv(dir);
	// 【2】数据标准化
	QStringList Time;
	mat MatFBGT;
	Stand_FBGT_Fix(CH, MatFBGT, Time);
	// 【3】保存文件
	bool b = saveStandData("Data-FBGTemperature", DataName_FBGT, Time, MatFBGT);
	return b;
}

// 数据标准化-FBGS(没有修复)-部署通道排序
bool standardFBGS(QString dir)
{
	// 【1】获取CH通道对应文件
	QStringList CH = get_FBGS_csv(dir);
	// 【2】数据标准化
	QStringList Time;
	mat MatFBGS;
	Stand_FBGS(CH, MatFBGS, Time);// 各通道数据转Mat并排序
	// 【3】保存文件
	bool b = saveStandData("Data-FBGStress", DataName_FBGS, Time, MatFBGS);
	return b;
}

// 数据标准化-环境温度(xls)-部署通道排序
bool standardENVxls(QString dir)
{
	// TODO
	// 暂未实现
	bool b = false;
	return b;
}

// FBG波长转温度(陈标定)
bool FBGTtoTEMP(QString standFBGTFileName)
{
	bool b = false;
	if (!standFBGTFileName.isEmpty())
	{
		// 【1】FBG波长转温度
		QStringList XLabelName;
		mat FBGWave = FBGtoTEMP(standFBGTFileName, XLabelName);
		// 【2】保存文件
		QString Date = standFBGTFileName.right(33).left(10);
		b = saveStandDataNoTimeFix("Data-FBGtoTEMP", DataName_FBGT, Date, XLabelName, FBGWave);
	}
	return b;
}

// 相关性分析-输入2个文件
bool correlationAnalysis(QString correlationFileName1, QString correlationFileName2)
{
	QStringList DataName1;
	QStringList DataName2;
	QStringList Time;
	// 【1】相关性计算
	mat corMatneed = CorrelationAnalysis(correlationFileName1, correlationFileName2, DataName1, DataName2, Time);
	JIO::show(corMatneed);
	qDebug() << DataName1;
	qDebug() << DataName2;
	// 【2】保存文件
	DataName1[0] = "相关性分析";
	DataName2.removeFirst();
	bool b = JIO::save(saveFilePath + "CorrelationAnalysis.csv", DataName1, DataName2, corMatneed);
//	bool b = saveCorrelationAnalysisCSV(correlationFileName1, correlationFileName2, DataName1, DataName2, corMatneed);
	return b;
}

// 多元线性回归-输入文件名
bool LinearRegression(QString inputFile)
{
	// 【1】载入\计算 (多元线性回归核心算法)
	QString strOutCsv;
	QString strOut = QLinearRegression(inputFile, strOutCsv);
	//qDebug()<<strOut;
	// 【2】保存文件
	QString outFileName = inputFile.right(inputFile.size() - inputFile.lastIndexOf('/') - 1);
	outFileName = outFileName.left(outFileName.lastIndexOf('.'));
	outFileName += "-LRparameters.csv";
	//qDebug()<<"outFileName"<<outFileName;
	bool b = JIO::save(saveFilePath + outFileName, strOutCsv);
	// 保存C语言风格的数组
	QString CStyleArrayStr{ "double Answerx[cols]={" };
	CStyleArrayStr += strOutCsv + "};";
	outFileName.replace(QRegExp("\\.csv"), ".cpp");
	JIO::save(saveFilePath + "Code_" + outFileName, CStyleArrayStr);
	return b;
}

// 多元线性回归预测-输入模型、训练数据集
bool LinearRegressionPredict(QString ModelFile, QString DataFile)
{
	bool b = false;
	QList<double> ModelMatQList; // 模型参数文件
	QList<QList<double>> ModelMat = JIO::readMat(ModelFile);
	for (auto &e : ModelMat[0])
	{
		ModelMatQList.append(e);
	}
	qDebug() << "ModelMatQList.size() " << ModelMatQList.size();
	if (ModelMat.size() == 1 && ModelMatQList.size() > 0)
	{
		qDebug("模型载入成功！");
	}


	QList<QList<double>> DataFileMat = JIO::readMat(DataFile);
	if (DataFileMat[0].size() != (ModelMatQList.size() - 1))
	{
		qDebug("模型、预测数据不匹配！");
	}
	else
	{
		// 计算预测值
		QList<double> predictedValueList;
		double predictedValue = 0;
		for (int i = 0; i < DataFileMat.size(); ++i)
		{
			for (int j = 0; j < ModelMatQList.size(); ++j)
			{
				if (j == 0)
					predictedValue = ModelMatQList[0];
				else
				{
					predictedValue += ModelMatQList[j] * DataFileMat[i][j - 1];
				}
			}
			predictedValueList.append(predictedValue);
		}
		//		qDebug()<<"predictedValueLists "<<predictedValueList.size();
		//		qDebug()<<"predictedValueList0 "<<predictedValueList[0];
		//		qDebug()<<"predictedValueList1 "<<predictedValueList[1];
		//		qDebug()<<"predictedValueList2 "<<predictedValueList[2];

		for (int i = 0; i < DataFileMat.size(); ++i)
		{
			DataFileMat[i].append(predictedValueList[i]);
		}
		// 提取文件名
		QString outFileName = DataFile.right(DataFile.size() - DataFile.lastIndexOf('/') - 1);
		outFileName = outFileName.left(outFileName.lastIndexOf('.'));
		outFileName += "-predictedResult.csv";
		JIO::save(saveFilePath + outFileName, DataFileMat);
		b = true;
	}
	return b;
}

// 数据概览-csv文件基本统计分析
bool csvStatisticAnalysis(QString InputFileName_str)
{
	bool b = false;
	qDebug() << InputFileName_str;  // 文件名

	if (!InputFileName_str.isEmpty())
	{
		// 需要变量
		QStringList DataName; // 数据各项名
		QString strMatRow;
		QString strMatCol;
		QString strTitle;
		QString strMatSum;
		QString strMatArit;
		QString strMatMax;
		QString strMatMin;
		// 【1】数据分析
		mat Mat = DataAnalysis(InputFileName_str, DataName, strMatRow, strMatCol, strTitle, strMatSum, strMatArit, strMatMax, strMatMin);
		// 【2】数据概览-处理
		qDebug() << "数据行列：" + strMatRow + " x " + strMatCol;
		qDebug() << "数据名字：" + strTitle;
		qDebug() << "数据总和：" + strMatSum;
		qDebug() << "数据平均：" + strMatArit;
		qDebug() << "数据最大：" + strMatMax;
		qDebug() << "数据最小：" + strMatMin;
		// 【3】数据诊断
		b = DataDiagnosis(InputFileName_str, Mat, DataName);
	}
	return b;
}

// 数据小处理-初始值为0
bool dataZeroMat(QString fileName)
{
	// 【1】初始值为0算法
	mat inputMat = JIO::readAMat(fileName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列
	{
		double oneLineValue = inputMat(0, j);
		for (unsigned int i = 0; i < inputMat.n_rows; ++i) // 遍历行，减第一行的值
		{
			inputMat(i, j) = inputMat(i, j) - oneLineValue;
		}
	}
	// 【2】保存文件
	QString saveFileName = "Zero_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, inputMat);
	return b;
}

bool dataZeroCsv(QString fileName)
{
	// 【1】初始值为0算法
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列
	{
		double oneLineValue = inputMat(0, j);
		for (unsigned int i = 0; i < inputMat.n_rows; ++i) // 遍历行，减第一行的值
		{
			inputMat(i, j) = inputMat(i, j) - oneLineValue;
		}
	}
	// 【2】保存文件
	QString saveFileName = "Zero_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, itemName, timeName, inputMat);
	return b;
}

// 数据小处理-增量化（后一个数-前一个数）
bool dataDeltaMat(QString fileName)
{
	// 【1】增量化算法
	mat inputMat = JIO::readAMat(fileName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (int i = inputMat.n_rows - 1; i > 0; --i) // 行n行到1行-倒序
		{
			inputMat(i, j) = inputMat(i, j) - inputMat(i - 1, j);
		}
	}
	// 【2】保存文件
	QString saveFileName = "Delta_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, inputMat);
	return b;
}

bool dataDeltaCsv(QString fileName)
{
	// 【1】增量化算法
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (int i = inputMat.n_rows - 1; i > 0; --i) // 行n行到1行-倒序
		{
			inputMat(i, j) = inputMat(i, j) - inputMat(i - 1, j);
		}
	}
	// 【2】保存文件
	QString saveFileName = "Delta_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, itemName, timeName, inputMat);
	return b;
}

// 数据小处理-压缩拉伸
bool dataSamplingMat(QString fileName, int &nowNum ,int needNum)
{
	// 【1】压缩拉伸算法
	mat inputMat = JIO::readAMat(fileName);
	nowNum = inputMat.n_rows;
	QList<int> needLine = sampling(nowNum, needNum);
	mat out(needLine.size(), inputMat.n_cols);
	out.fill(0);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (int i = 0; i < needLine.size(); ++i) // 行
		{
			out(i, j) = inputMat(needLine[i], j);
		}
	}
	// 【2】保存文件
	QString saveFileName;
	if (nowNum >= needNum)
		saveFileName = "Minus_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	else
		saveFileName = "Add_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, out);
	if (b)
		if (nowNum >= needNum)
			qDebug("压缩 处理成功!");
		else
			qDebug("拉伸 处理成功!");
	return b;
}

bool dataSamplingCsv(QString fileName, int &nowNum ,int needNum)
{
	// 【1】压缩拉伸算法
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);
	nowNum = inputMat.n_rows;
	QList<int> needLine = sampling(nowNum, needNum);
	mat out(needLine.size(), inputMat.n_cols);
	out.fill(0);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (int i = 0; i < needLine.size(); ++i) // 行
		{
			out(i, j) = inputMat(needLine[i], j);
		}
	}
	// 【2】保存文件
	// 时间列也需要抽样
	QStringList timeNameNeed;
	for(auto i=0; i<needLine.size(); ++i)
	{
		timeNameNeed.append( timeName.at( needLine[i]) );
	}
	QString saveFileName;
	if (nowNum >= needNum)
		saveFileName = "Minus_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	else
		saveFileName = "Add_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, itemName, timeNameNeed, out);
	if (b)
		if (nowNum >= needNum)
			qDebug("压缩 处理成功!");
		else
			qDebug("拉伸 处理成功!");
	return b;
}

// 数据小处理-数据清洗(设定阈值内数据，前一个值覆盖后一个值)
bool dataCleanMat(QString fileName, double maxNum, double minNum)
{
	// 【1】数据清洗算法
	mat inputMat = JIO::readAMat(fileName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (unsigned int i = 1; i < inputMat.n_rows; ++i) // 行
		{
			double value = inputMat(0, j);
			inputMat(0, j) = (maxNum - value) > (value - minNum) ? minNum : maxNum;
			// 超出范围执行
			if (inputMat(i, j) > maxNum || inputMat(i, j) < minNum)
			{
				// 确保上一个不超出范围
				if (inputMat(i - 1, j) > minNum && inputMat(i - 1, j) < maxNum)
					inputMat(i, j) = inputMat(i - 1, j);
				else
				{
					auto val = inputMat(i, j);
					inputMat(i, j) = (maxNum - val) > (val - minNum) ? minNum : maxNum;
				}
			}
		}
	}
	// 【2】保存文件
	QString saveFileName = "Clean_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, inputMat);
	return b;
}

bool dataCleanCsv(QString fileName, double maxNum, double minNum)
{
	// 【1】数据清洗算法
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		for (unsigned int i = 1; i < inputMat.n_rows; ++i) // 行
		{
			double value = inputMat(0, j);
			inputMat(0, j) = (maxNum - value) > (value - minNum) ? minNum : maxNum;
			// 超出范围执行
			if (inputMat(i, j) > maxNum || inputMat(i, j) < minNum)
			{
				// 确保上一个不超出范围
				if (inputMat(i - 1, j) > minNum && inputMat(i - 1, j) < maxNum)
					inputMat(i, j) = inputMat(i - 1, j);
				else
				{
					auto val = inputMat(i, j);
					inputMat(i, j) = (maxNum - val) > (val - minNum) ? minNum : maxNum;
				}
			}
		}
	}
	// 【2】保存文件
	QString saveFileName = "Clean_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, itemName, timeName, inputMat);
	return b;
}

// 数据小处理-趋势预测
bool dataTendencyMat(QString fileName, int window)
{
	// 【1】趋势预测算法
	mat inputMat = JIO::readAMat(fileName);
	mat matMaxOut;
	mat matMinOut;
	mat matAvgOut;
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		QList<double> input;
		QList<double> outMax;
		QList<double> outMin;
		QList<double> outAvg;
		// 得到QList输入
		for (unsigned int i = 1; i < inputMat.n_rows; ++i) // 行
		{
			input.append(inputMat(i, j));
		}
		// 加窗滤波
		findTrendByWindow(input, window, outMax, outMin, outAvg);
		// 写入mat
		mat matMax(outMax.size(), 1);
		mat matMin(outMin.size(), 1);
		mat matAvg(outAvg.size(), 1);
		for (unsigned int i = 0; i < matMax.n_rows; ++i)
		{
			matMax(i, 0) = outMax[i];
			matMin(i, 0) = outMin[i];
			matAvg(i, 0) = outAvg[i];
		}
		// 合入大mat
		matMaxOut = join_rows(matMaxOut, matMax);
		matMinOut = join_rows(matMinOut, matMin);
		matAvgOut = join_rows(matAvgOut, matAvg);
	}
	// 【2】保存文件
	QString saveFileName1 = "TrendMax_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	QString saveFileName2 = "TrendMin_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	QString saveFileName3 = "TrendAvg_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b1 = JIO::save(saveFilePath + saveFileName1, matMaxOut);
	bool b2 = JIO::save(saveFilePath + saveFileName2, matMinOut);
	bool b3 = JIO::save(saveFilePath + saveFileName3, matAvgOut);
	return b1 && b2 && b3;
}

bool dataTendencyCsv(QString fileName, int window)
{
	// 【1】趋势预测算法
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);
	mat matMaxOut;
	mat matMinOut;
	mat matAvgOut;
	for (unsigned int j = 0; j < inputMat.n_cols; ++j) // 列 0列到n列
	{
		QList<double> input;
		QList<double> outMax;
		QList<double> outMin;
		QList<double> outAvg;
		// 得到QList输入
		for (unsigned int i = 1; i < inputMat.n_rows; ++i) // 行
		{
			input.append(inputMat(i, j));
		}
		// 加窗滤波
		findTrendByWindow(input, window, outMax, outMin, outAvg);
		// 写入mat
		mat matMax(outMax.size(), 1);
		mat matMin(outMin.size(), 1);
		mat matAvg(outAvg.size(), 1);
		for (unsigned int i = 0; i < matMax.n_rows; ++i)
		{
			matMax(i, 0) = outMax[i];
			matMin(i, 0) = outMin[i];
			matAvg(i, 0) = outAvg[i];
		}
		// 合入大mat
		matMaxOut = join_rows(matMaxOut, matMax);
		matMinOut = join_rows(matMinOut, matMin);
		matAvgOut = join_rows(matAvgOut, matAvg);
	}
	// 【2】保存文件
	QString saveFileName1 = "TrendMax_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	QString saveFileName2 = "TrendMin_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	QString saveFileName3 = "TrendAvg_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b1 = JIO::save(saveFilePath + saveFileName1, itemName, timeName, matMaxOut);
	bool b2 = JIO::save(saveFilePath + saveFileName2, itemName, timeName, matMinOut);
	bool b3 = JIO::save(saveFilePath + saveFileName3, itemName, timeName, matAvgOut);
	return b1 && b2 && b3;
}

// 数据小处理-按天拆分
bool dataSplitByDateCsv(QString fileName)
{
	// 【1】虚拟映射算法
	QStringList inputList = JIO::readFile(fileName);
	QString itemName = inputList[0];
	qDebug() << "itemName" << itemName;
	// 得到日期集合
	QSet<QString> dateSet;
	for (auto e : inputList)
	{
		if (e.left(4) != "Time") // 排除第一行
			dateSet.insert(e.left(10));
	}

	// 【2】保存文件-保存"日期个数"个文件
	bool b = true;
	for (QString dateName : dateSet)
	{
		qDebug() << dateName;
		QString saveName = saveFilePath + dateName + "_" + getFileName(fileName);
		QFile f(saveName);
		qDebug() << saveName;
		if (!f.open(QIODevice::WriteOnly | QIODevice::Text))
		{
			qDebug() << "[on_pushButton_SplitByDate_clicked] Open failed.";
			b = false;
		}
		QTextStream txtOutput(&f);
		txtOutput << itemName << "\n";
		for (auto e : inputList)
		{
			if (e.left(10) == dateName)
				txtOutput << e.right(e.size() - 11) << "\n"; // 去掉日期
		}
		f.close();
	}
	return b;
}

// 数据小处理-csv合并
bool mergeCsv(QStringList fileNameList)
{
	bool b = false;
	if (fileNameList.size() <= 1)
	{
		qDebug("请选择2个或以上数目的文件！");
	}
	else
	{
		// 【1】第一个文件：追加写入
		QFile f(fileNameList[0]);
		if (!f.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text))
		{
			qDebug() << "[f.open] 打开失败！";
			b = false;
			return b;
		}
		QTextStream txtOutput(&f);

		// 【2】从此读入第2、3...个文件，跳过“第1行”, 写入第一个文件
		for (auto i = 1; i<fileNameList.size(); ++i)
		{
			QFile f2(fileNameList[i]);
			if (!f2.open(QIODevice::ReadOnly | QIODevice::Text))
			{
				qDebug("[f2.open] 打开失败！");
			}
			QTextStream txtInput2(&f2);
			int lineNum = 0;
			while (!txtInput2.atEnd())
			{
				QString lineStr = txtInput2.readLine();
				if (lineNum != 0) // 跳过“第1行”
					txtOutput << lineStr << "\n";
				//qDebug() << i  <<"   :" <<  lineNum  <<"   :"<<lineStr;
				lineNum++;
			}
			f2.close();
		}

		// 第一个文件：关闭
		f.close();
		b = true;
	}
	return b;
}

// 数据小处理-时间规范化(小于30归零，大于30写30)
bool timeStandCsv(QString fileName)
{
	QStringList itemName;
	QStringList timeName;
	mat inputMat = JIO::readCsv(fileName, itemName, timeName);

	if(timeName[0].size() == 19) // 2017-08-13 19:44:05
	{
		qDebug("timeName.size() == 19");
		for(auto i=0; i<timeName.size(); ++i)
		{
			if( timeName[i].right(2) < "30" )
				timeName[i] = timeName[i].left(17) + "00";
			else
				timeName[i] = timeName[i].left(17) + "30";
		}
	}
	if(timeName[0].size() == 8) // 19:44:05
	{
		qDebug("timeName.size() == 8");
		for(auto i=0; i<timeName.size(); ++i)
		{
			if( timeName[i].right(2) < "30" )
				timeName[i] = timeName[i].left(6) + "00";
			else
				timeName[i] = timeName[i].left(6) + "30";
		}
	}
	if(timeName[0].size() == 14) // 20170813194405
	{
		qDebug("timeName.size() == 14");
		for(auto i=0; i<timeName.size(); ++i)
		{
			if( timeName[i].right(2) < "30" )
				timeName[i] = timeName[i].left(12) + "00";
			else
				timeName[i] = timeName[i].left(12) + "30";
		}
	}
	QString saveFileName = "timeStand_" + fileName.right(fileName.size() - fileName.lastIndexOf('/') - 1);
	bool b = JIO::save(saveFilePath + saveFileName, itemName, timeName, inputMat);
	return b;
}

// 虚拟映射-数据通道映射为虚拟标准通道-FBG温度
bool virtualMapFBGT(QStringList fileNameList)
{
	bool b = false;
	for (QString fileName : fileNameList)
	{
		if (!fileName.isEmpty())
		{
			// 【1】虚拟映射算法
			QStringList itemName;
			QStringList timeName;
			mat inputMat = JIO::readCsv(fileName, itemName, timeName);
			mat outputMat;
			for (int i = 0; i < 219; ++i) // FBG温度219个
			{
				outputMat = join_rows(outputMat, inputMat.col(VirtualMap_FBGT_Index[i]));
			}
			// 【2】保存文件
			QString saveFileName = getFileName(fileName);
			saveFileName = saveFileName.left(10) + "_FBGT_Wave.csv";
			b = JIO::save(saveFilePath + saveFileName, VirtualMap_FBGT_Now, timeName, outputMat);
		}
	}
	return b;
}

// 虚拟映射-数据通道映射为虚拟标准通道-FBG应力
bool virtualMapFBGS(QStringList fileNameList)
{
	bool b = false;
	for (QString fileName : fileNameList)
	{
		if (!fileName.isEmpty())
		{
			// 【1】虚拟映射算法
			QStringList itemName;
			QStringList timeName;
			mat inputMat = JIO::readCsv(fileName, itemName, timeName);
			mat outputMat;
			for (int i = 0; i < 90; ++i) // FBG应力90个
			{
				outputMat = join_rows(outputMat, inputMat.col(VirtualMap_FBGS_Index[i]));
			}
			// 【2】保存文件
			QString saveFileName = getFileName(fileName);
			saveFileName = saveFileName.left(10) + "_FBGS_Wave.csv";
			b = JIO::save(saveFilePath + saveFileName, VirtualMap_FBGS_Now, timeName, outputMat);
		}
	}
	return b;
}

// 虚拟映射-数据通道映射为虚拟标准通道-电类温度
bool virtualMapDS18(QStringList fileNameList)
{
	// 电类温度不需要交换位置，只需要改抬头
	bool b = false;
	for (QString fileName : fileNameList)
	{
		if (!fileName.isEmpty())
		{
			// 【1】虚拟映射算法
			QStringList itemName;
			QStringList timeName;
			mat inputMat = JIO::readCsv(fileName, itemName, timeName);
			// 【2】保存文件
			QString saveFileName = getFileName(fileName);
			saveFileName = saveFileName.left(10) + "_DS18_Temp.csv";
			b = JIO::save(saveFilePath + saveFileName, VirtualMap_DS18_Now, timeName, inputMat);
		}
	}
	return b;
}

double VirtualCalibrationWave[219] = { 1535.867297,1537.898297,1539.888297,1541.932297,1543.881297,1545.874297,1547.866297,1549.865297,1551.858297,1553.894297,1555.881297,1557.893297,1559.860297,1561.834297,1563.778297,1535.808297,1537.832297,1539.819297,1541.861297,1543.839297,1545.809297,1547.795297,1549.811297,1551.792297,1553.795297,1555.860297,1557.874297,1559.894297,1562.029297,1564.040297,1535.815297,1537.827297,1539.808297,1541.838297,1543.817297,1545.785297,1547.790297,1549.762297,1551.890297,1553.870297,1555.909297,1557.923297,1559.911297,1561.912297,1563.887297,1535.827297,1537.807297,1539.781297,1541.826297,1543.809297,1545.787297,1547.780297,1549.829297,1551.969297,1553.993297,1555.947297,1557.783297,1559.803297,1561.900297,1563.805297,1547.761297,1545.786297,1543.788297,1541.881297,1539.835297,1537.848297,1535.841297,1549.802297,1551.869297,1553.960297,1555.991297,1558.023297,1559.904297,1561.915297,1563.855297,1549.939297,1547.909297,1545.902297,1543.949297,1541.955297,1539.918297,1537.958297,1535.895297,1551.846297,1553.848297,1555.213297,1557.860297,1559.810297,1561.885297,1563.800297,1537.812297,1540.913297,1543.840297,1546.784297,1537.779297,1540.773297,1543.799297,1546.730297,1537.809297,1540.797297,1543.833297,1546.793297,1536.790297,1539.761297,1542.678297,1545.750297,1548.723297,1551.821297,1554.698297,1557.708297,1560.744297,1564.198297,1537.858297,1540.838297,1543.730297,1546.779297,1549.710297,1552.768297,1555.864297,1558.796297,1561.764297,1565.784297,1537.820297,1540.742297,1543.675297,1546.747297,1549.676297,1552.742297,1555.818297,1558.698297,1561.761297,1536.780297,1539.734297,1542.724297,1545.775297,1548.729297,1551.877297,1554.742297,1557.755297,1560.724297,1563.722297,1537.849297,1540.793297,1543.727297,1546.775297,1549.831297,1552.720297,1555.860297,1558.760297,1561.718297,1565.773297,1536.825297,1539.834297,1542.708297,1545.727297,1548.845297,1551.839297,1554.708297,1557.712297,1560.745297,1563.705297,1537.781297,1540.792297,1543.697297,1546.728297,1549.697297,1552.745297,1555.815297,1558.726297,1561.754297,1565.731297,1531.952654,1535.208654,1538.214654,1541.188654,1544.226654,1547.039654,1550.096654,1553.297654,1556.012654,1559.115654,1547.147654,1553.152654,1556.172654,1558.995654,1556.524654,1559.640654,1533.068654,1536.184654,1537.912654,1541.676654,1544.517654,1547.761654,1550.465654,1553.851654,1532.840654,1535.916654,1539.192654,1541.856654,1544.839654,1547.867654,1551.151654,1553.933654,1557.041654,1560.122654,1532.031654,1535.036654,1538.058654,1540.987654,1560.525654,1557.618654,1532.885654,1536.390654,1539.320654,1542.156654,1545.346654,1548.191654,1551.463654,1555.809654 };
//double VirtualCalibrationWave_201706[219] = {1535.904935,1537.922935,1539.914935,1541.995935,1543.939935,1545.929935,1547.917935,1549.916935,1551.879935,1553.920935,1555.913935,1557.932935,1559.930935,1561.887935,1563.856935,1535.783935,1537.795935,1539.763935,1541.805935,1543.773935,1545.736935,1547.697935,1549.711935,1551.760935,1553.772935,1555.841935,1557.852935,1559.863935,1561.968935,1563.999935,1535.852935,1537.867935,1539.850935,1541.882935,1543.860935,1545.827935,1547.825935,1549.812935,1551.853935,1553.842935,1555.902935,1557.921935,1559.905935,1561.909935,1563.913935,1535.791935,1537.761935,1539.746935,1541.788935,1543.745935,1545.730935,1547.735935,1549.788935,1552.028935,1554.061935,1555.993935,1557.867935,1559.806935,1561.855935,1563.784935,1547.716935,1545.720935,1543.722935,1541.811935,1539.771935,1537.780935,1535.763935,1549.749935,1551.824935,1553.993935,1555.987935,1558.002935,1559.960935,1561.964935,1563.892935,1549.960935,1547.924935,1545.928935,1543.978935,1541.981935,1539.946935,1537.987935,1535.928935,1551.842935,1553.897935,1555.927935,1557.933935,1559.824935,1561.886935,1563.786935,1557.851935,1559.829935,1561.837935,1563.828935,1550.810935,1552.817935,1554.887935,1556.910935,1543.797935,1545.859935,1547.875935,1549.796935,1536.743935,1540.147935,1542.658935,1545.708935,1548.680935,1551.780935,1554.632935,1557.651935,1560.703935,1564.232935,1537.753935,1540.718935,1543.647935,1546.681935,1549.628935,1552.695935,1555.798935,1558.743935,1561.680935,1565.721935,1537.769935,1540.692935,1543.631935,1546.709935,1549.651935,1552.693935,1555.738935,1558.603935,1561.651935,1536.721935,1539.699935,1542.679935,1545.708935,1548.706935,1551.839935,1554.688935,1557.713935,1560.654935,1563.670935,1537.821935,1540.737935,1543.674935,1546.708935,1549.791935,1552.672935,1555.814935,1558.717935,1561.664935,1565.729935,1536.788935,1539.784935,1542.675935,1545.679935,1548.782935,1551.798935,1554.594935,1557.643935,1560.681935,1563.663935,1537.735935,1540.747935,1543.651935,1546.684935,1549.648935,1552.670935,1555.756935,1558.674935,1561.698935,1565.608935,1531.866373,1535.110373,1538.124373,1541.071373,1544.176373,1546.921373,1549.987373,1553.191373,1555.912373,1558.908373,1547.044373,1553.051373,1556.093373,1558.908373,1556.423373,1559.579373,1532.957373,1536.057373,1537.853373,1541.592373,1544.438373,1547.669373,1550.410373,1553.785373,1532.746373,1535.805373,1539.120373,1541.770373,1544.770373,1547.781373,1551.103373,1553.864373,1556.931373,1560.063373,1531.926373,1534.915373,1537.948373,1540.873373,1560.314373,1557.431373,1532.791373,1536.333373,1539.324373,1542.104373,1545.254373,1548.088373,1551.417373,1554.201373};
double VirtualCalibrationWave_201706[219] = { 1535.904935,1537.922935,1539.914935,1541.995935,1543.939935,1545.929935,1547.917935,1549.916935,1551.879935,1553.920935,1555.913935,1557.932935,1559.930935,1561.887935,1563.856935,1535.783935,1537.795935,1539.763935,1541.805935,1543.773935,1545.736935,1547.697935,1549.711935,1551.760935,1553.772935,1555.841935,1557.852935,1559.863935,1561.968935,1563.999935,1535.852935,1537.867935,1539.850935,1541.882935,1543.860935,1545.827935,1547.825935,1549.812935,1551.853935,1553.842935,1555.902935,1557.921935,1559.905935,1561.909935,1563.913935,1535.791935,1537.761935,1539.746935,1541.788935,1543.745935,1545.730935,1547.735935,1549.788935,1552.028935,1554.061935,1555.993935,1557.867935,1559.806935,1561.855935,1563.784935,1547.716935,1545.720935,1543.722935,1541.811935,1539.771935,1537.780935,1535.763935,1549.749935,1551.824935,1553.993935,1555.987935,1558.002935,1559.960935,1561.964935,1563.892935,1549.960935,1547.924935,1545.928935,1543.978935,1541.981935,1539.946935,1537.987935,1535.928935,1551.842935,1553.897935,1555.927935,1557.933935,1559.824935,1561.886935,1563.786935,1541.799899,1557.854899,1559.842899,1561.890899,1550.810935,1552.817935,1554.887935,1556.910935,1543.797935,1545.859935,1547.875935,1549.796935,1536.743935,1540.147935,1542.658935,1545.708935,1548.680935,1551.780935,1554.632935,1557.651935,1560.703935,1564.232935,1537.753935,1540.718935,1543.647935,1546.681935,1549.628935,1552.695935,1555.798935,1558.743935,1561.680935,1565.721935,1537.769935,1540.692935,1543.631935,1546.709935,1549.651935,1552.693935,1555.738935,1558.603935,1561.651935,1536.721935,1539.699935,1542.679935,1545.708935,1548.706935,1551.839935,1554.688935,1557.713935,1560.654935,1563.670935,1537.821935,1540.737935,1543.674935,1546.708935,1549.791935,1552.672935,1555.814935,1558.717935,1561.664935,1565.729935,1536.788935,1539.784935,1542.675935,1545.679935,1548.782935,1551.798935,1554.594935,1557.643935,1560.681935,1563.663935,1537.735935,1540.747935,1543.651935,1546.684935,1549.648935,1552.670935,1555.756935,1558.674935,1561.698935,1565.608935,1531.866373,1535.110373,1538.124373,1541.071373,1544.176373,1546.921373,1549.987373,1553.191373,1555.912373,1558.908373,1547.044373,1553.051373,1556.093373,1558.908373,1556.423373,1559.579373,1532.957373,1536.057373,1537.853373,1541.592373,1544.438373,1547.669373,1550.410373,1553.785373,1532.746373,1535.805373,1539.120373,1541.770373,1544.770373,1547.781373,1551.103373,1553.864373,1556.931373,1560.063373,1531.926373,1534.915373,1537.948373,1540.873373,1560.314373,1557.431373,1532.791373,1536.333373,1539.324373,1542.104373,1545.254373,1548.088373,1551.417373,1554.201373 };
// 虚拟映射-映射的FBG温度传感器转温度值
bool virtualFBGtoTEMP(QStringList fileNameList)
{
	bool b = false;
	for (QString fileName : fileNameList)
	{
		if (!fileName.isEmpty())
		{
			// 【1】FBG转温度算法
			QStringList itemName;
			QStringList timeName;
			mat inputMat = JIO::readCsv(fileName, itemName, timeName);
			for (unsigned int j = 0; j < inputMat.n_cols; ++j)
			{
				for (unsigned int i = 0; i < inputMat.n_rows; ++i)
				{
					double value;
					if (j <= 170) // 0.0105 其它
					{
						value = 1.0 / 0.0105*(inputMat(i, j) - VirtualCalibrationWave_201706[j]);
						if (value >= 0 && value <= 100)
							inputMat(i, j) = value;
						else
							inputMat(i, j) = 0;
					}
					if (j > 170) // 0.0400 立柱
					{
						value = 1.0 / 0.0400*(inputMat(i, j) - VirtualCalibrationWave_201706[j]);
						if (value >= 0 && value <= 100)
							inputMat(i, j) = value;
						else
							inputMat(i, j) = 0;
					}
				}
			}
			// 【2】保存文件
			QString saveFileName = getFileName(fileName);
			saveFileName = saveFileName.left(10) + "_FBGT_Temp.csv";
			QString itemNameStr = itemName.join(",");
			b = JIO::save(saveFilePath + saveFileName, itemNameStr, timeName, inputMat);
		}
	}
	return b;
}

// 应力换算2017-02-27第一次次数据-以此为基准
double FBGS_Wave[90] = { 1536.538,1538.491,1540.669,1543.024,1545.057,1547.014,1549.062,1551.084,1552.100,1554.442,1556.414,1558.423,1560.364,1562.381,1564.149,1536.524,1538.377,1540.426,1542.449,1544.438,1546.725,1548.604,1552.087,1552.087,1554.266,1556.450,1558.222,1560.152,1562.522,1564.342,1536.611,1538.430,1540.360,1542.215,1544.126,1546.174,1548.263,1550.272,1552.234,1554.399,1556.324,1558.156,1560.258,1562.358,1564.019,1536.208,1538.193,1540.164,1542.220,1544.249,1546.220,1547.654,1550.319,1552.137,1554.136,1555.328,1558.223,1560.197,1561.972,1564.187,1548.145,1546.272,1544.277,1542.351,1540.403,1538.269,1536.357,1550.186,1552.186,1554.295,1556.523,1559.289,1560.399,1562.205,1564.002,0.000,0.000,0.000,0.000,0.000,0.000,1548.492,1550.196,1552.032,1554.376,1556.247,1558.303,1560.322,1562.776,1564.310 };
double FBGT_Wave[90] = { 1536.001,1538.032,1540.022,1542.066,1544.015,1546.008,1548,1549.999,1551.992,1554.028,1556.015,1558.027,1559.994,1561.968,1563.912,1535.942,1537.966,1539.953,1541.995,1543.973,1545.943,1547.929,1549.945,1551.926,1553.929,1555.994,1558.008,1560.028,1562.163,1564.174,1535.949,1537.961,1539.942,1541.972,1543.951,1545.919,1547.924,1549.896,1552.024,1554.004,1556.043,1558.057,1560.045,1562.046,1564.021,1535.961,1537.941,1539.915,1541.96,1543.943,1545.921,1547.914,1549.963,1552.103,1554.127,1556.081,1557.917,1559.937,1562.034,1563.939,1547.895,1545.92,1543.922,1542.015,1539.969,1537.982,1535.975,1549.936,1552.003,1554.094,1556.125,1558.157,1560.038,1562.049,1563.989,1550.073,1548.043,1546.036,1544.083,1542.089,1540.052,1538.092,1536.029,1551.98,1553.982,1555.347,1557.994,1559.944,1562.019,1563.934 };
// 虚拟映射-映射的FBG应力传感器转应力
bool virtualFBGtoSTRESS(QStringList fileNameList)
{
	bool b = false;

	if (fileNameList.size() != 2)
	{
		qDebug("文件状态：未载入");
		qDebug("请选择配套的应力、温度2个文件！");
	}
	else
	{
		QString fileNameTemp;
		QString fileNameStress;
		for (QString fileName : fileNameList)
		{
			if (fileName.right(10) == "T_Wave.csv")
				fileNameTemp = fileName;
			if (fileName.right(10) == "S_Wave.csv")
				fileNameStress = fileName;
		}

		if (!fileNameTemp.isEmpty() && !fileNameStress.isEmpty())
		{
			//【1】应力换算算法-两个数组
			QStringList itemNameT;
			QStringList timeNameT;
			mat inputTempALL = JIO::readCsv(fileNameTemp, itemNameT, timeNameT);

			QStringList itemNameS;
			QStringList timeNameS;
			mat inputStress = JIO::readCsv(fileNameStress, itemNameS, timeNameS);

			// 套入公式
			for (unsigned int j = 0; j < inputStress.n_cols; ++j)
			{
				//				// 核心公式-相对于2月26日数据
				//				for(unsigned int i=0; i<inputStress.n_rows;++i)
				//				{
				//					inputStress(i,j) = ((inputStress(i,j)-FBGS_Wave[j])/FBGS_Wave[j]-0.920863*(inputTempALL(i,j)-FBGT_Wave[j])/FBGT_Wave[j])/0.776*1000000;
				//				}

				// 核心公式-相对于第一条数据
				for (unsigned int i = 1; i < inputStress.n_rows; ++i)
				{
					// 核心公式-相对于第一条数据
					if (inputStress(0, j) != 0 && inputTempALL(0, j) != 0)
						inputStress(i, j) = ((inputStress(i, j) - inputStress(0, j)) / inputStress(0, j) - 0.920863*(inputTempALL(i, j) - inputTempALL(0, j)) / inputTempALL(0, j)) / 0.776 * 1000000;
					else
						inputStress(i, j) = 0;
				}
				inputStress(0, j) = 0; // 每天相对则需要+这句

			}
			// 【2】保存文件
			QString saveFileName = getFileName(fileNameStress);
			saveFileName = saveFileName.left(10) + "_FBGS_Stress.csv";
			QString itemNameStr = itemNameS.join(",");
			b = JIO::save(saveFilePath + saveFileName, itemNameStr, timeNameS, inputStress);
		}
	}
	return b;
}

// 一键环境温度数据映射
bool OriENVtoVirtual(QStringList EnvFileNameList)
{
	bool b;
	if (EnvFileNameList.size() != 4)
	{
		qDebug("请选择环境温度的4个txt文件！");
		b = false;
	}
	else
	{
		// 读取txt文件
		QString FileNameA;
		QString FileNameB;
		QString FileNameC;
		QString FileNameD;
		for (int i = 0; i < EnvFileNameList.size(); i++)
		{
			QString FileName = EnvFileNameList[i];
			QString ID = FileName.right(16).left(1); // 提取文件名中的ABCD以区分，例如“WHUT-A_2017-05-02.txt”
			if (ID == "A") FileNameA = FileName;
			if (ID == "B") FileNameB = FileName;
			if (ID == "C") FileNameC = FileName;
			if (ID == "D") FileNameD = FileName;
		}
		QList<QList<QString>>  Afile = JIO::readCsv(FileNameA, "\t");
		QList<QList<QString>>  Bfile = JIO::readCsv(FileNameB, "\t");
		QList<QList<QString>>  Cfile = JIO::readCsv(FileNameC, "\t");
		QList<QList<QString>>  Dfile = JIO::readCsv(FileNameD, "\t");

		// txt中读取文件到map
		QMap<QString, float> mapA;
		QMap<QString, float> mapB;
		QMap<QString, float> mapC;
		QMap<QString, float> mapD;
		for (int i = 8; i < Afile.size(); ++i)
		{
			mapA.insert(Afile[i][1].left(16), Afile[i][2].toFloat()); // .left(16)取时间到分钟
		}
		for (int i = 8; i < Bfile.size(); ++i)
		{
			mapB.insert(Bfile[i][1].left(16), Bfile[i][2].toFloat());
		}
		for (int i = 8; i < Cfile.size(); ++i)
		{
			mapC.insert(Cfile[i][1].left(16), Cfile[i][2].toFloat());
		}
		for (int i = 8; i < Dfile.size(); ++i)
		{
			mapD.insert(Dfile[i][1].left(16), Dfile[i][2].toFloat());
		}
		//		qDebug()<<"mapA.size："<<mapA.size();
		//		qDebug()<<"mapB.size："<<mapB.size();
		//		qDebug()<<"mapC.size："<<mapC.size();
		//		qDebug()<<"mapD.size："<<mapD.size();
		//		qDebug()<<"mapD.firstKey："<<mapD.firstKey();
		//		qDebug()<<"mapD.firstValue："<<mapD.value(mapD.firstKey());

		// 找出共有的【最晚开始时间】和【最早结束时间】
		QString startDate;
		QString endDate;
		QMap<QString, float>::const_iterator i;
		for (i = mapA.constBegin(); i != mapA.constEnd(); ++i)
		{
			if (i == mapA.constBegin())  startDate = i.key();
			if (i + 1 == mapA.constEnd())  endDate = i.key();
		}
		for (i = mapB.constBegin(); i != mapB.constEnd(); ++i)
		{
			if (i == mapB.constBegin())  startDate = QString::compare(i.key(), startDate) >= 0 ? i.key() : startDate;
			if (i + 1 == mapB.constEnd())  endDate = QString::compare(i.key(), endDate) <= 0 ? i.key() : endDate;
		}
		for (i = mapC.constBegin(); i != mapC.constEnd(); ++i)
		{
			if (i == mapC.constBegin())  startDate = QString::compare(i.key(), startDate) >= 0 ? i.key() : startDate;
			if (i + 1 == mapC.constEnd())  endDate = QString::compare(i.key(), endDate) <= 0 ? i.key() : endDate;
		}
		for (i = mapD.constBegin(); i != mapD.constEnd(); ++i)
		{
			if (i == mapD.constBegin())  startDate = QString::compare(i.key(), startDate) >= 0 ? i.key() : startDate;
			if (i + 1 == mapD.constEnd())  endDate = QString::compare(i.key(), endDate) <= 0 ? i.key() : endDate;
		}
		qDebug() << "公共开始时间:" << startDate << " 公共结束时间:" << endDate;

		// 制作整合的数据（Key为时间，value为,分隔4个值）例如："2017-04-25 13:23"、"19.6,19.4,19.3,19.5"
		QMap<QString, QString> mapAll;
		for (i = mapA.constBegin(); i != mapA.constEnd(); ++i)
		{
			if (QString::compare(i.key(), startDate) >= 0 && QString::compare(i.key(), endDate) <= 0)
			{
				QString value = QString::number(i.value());
				mapAll.insert(i.key(), value);
			}
		}
		for (i = mapB.constBegin(); i != mapB.constEnd(); ++i)
		{
			if (QString::compare(i.key(), startDate) >= 0 && QString::compare(i.key(), endDate) <= 0)
			{
				QString value = "," + QString::number(i.value());
				mapAll.insert(i.key(), mapAll[i.key()] + value);
			}
		}
		for (i = mapC.constBegin(); i != mapC.constEnd(); ++i)
		{
			if (QString::compare(i.key(), startDate) >= 0 && QString::compare(i.key(), endDate) <= 0)
			{
				QString value = "," + QString::number(i.value());
				mapAll.insert(i.key(), mapAll[i.key()] + value);
			}
		}
		for (i = mapD.constBegin(); i != mapD.constEnd(); ++i)
		{
			if (QString::compare(i.key(), startDate) >= 0 && QString::compare(i.key(), endDate) <= 0)
			{
				QString value = "," + QString::number(i.value());
				mapAll.insert(i.key(), mapAll[i.key()] + value);
			}
		}

		// 保存文件
		QString Text = "Time,Back,Right,Left,Front";
		QString SaveFileName = startDate.left(10) + "~" + endDate.left(10) + "_ENV.csv";
		QFile file(saveFilePath + SaveFileName);
		file.open(QIODevice::WriteOnly | QIODevice::Append); // 存在打开，不存在创建
															 // 写抬头
		QTextStream txtOutput(&file);
		txtOutput << Text << "\n";
		// 写数据
		for (auto ii = mapAll.constBegin(); ii != mapAll.constEnd(); ++ii)
		{
			Text = ii.key() + ":00," + ii.value();// 时间还原到秒
			txtOutput << Text << "\n";
			//			qDebug()<< "Key:"<< ii.key() << " Value:" << ii.value();
		}
		file.close();
		b = true;
	}
	return b;
}

// 虚拟映射-电类环境温度数据映射
bool OriDS18ENVtoVirtual(QString dir)
{
	QString CH1 = dir + "/通道1.csv";
	QString CH2 = dir + "/通道2.csv";
	QStringList itemName1,itemName2;
	QStringList timeName,timeName_;
	mat input1 = JIO::readCsv(CH1, itemName1, timeName);
	mat input2 = JIO::readCsv(CH2, itemName2, timeName_);
	mat output(input1.n_rows,4);
	output.fill(0);

	QStringList ID1{"ID:28ffe7cc001604cf", "ID:28f3deee050000a0"};
	QStringList ID2{"ID:28ff2cf700160441", "ID:28ff7cff001604c8"};


	itemName1.removeFirst();
	itemName2.removeFirst();

	for(auto i=0; i<2; ++i)
	{
		for(auto j=0; j<ID1.size(); ++j)
		{
			if(itemName1[i] == ID1[j])
			{
				output.col(i+2) = input1.col(j);
			}
		}
	}
	for(auto i=0; i<2; ++i)
	{
		for(auto j=0; j<ID2.size(); ++j)
		{
			if(itemName2[i] == ID2[j])
			{
				output.col(i) = input2.col(j);
			}
		}
	}
	// 时间变成 时：分：秒
	QString Date;
	Date = timeName[0].left(10);
	for(auto &e: timeName)
	{
		e = e.right(8);
	}
	QStringList itemName{"Time", "LeftTop", "LeftBottom", "RightTop", "RightBottom"};
	bool b = JIO::save(saveFilePath + Date +"_ENVDS18.csv", itemName, timeName, output);
	return b;
}

// 一键原始电类数据映射
bool OriDS18toVirtual(QString dir)
{
	mat MatDS18B20;
	// 【1】获取CH通道对应文件
	QStringList CH = get_DS18B20_csv(dir);
	// 【2】数据标准化
	QStringList Time;
	Stand_DS18B20(CH, MatDS18B20, Time);// 各通道数据转Mat并排序
										// 【3】保存文件-直接保存虚拟通道数据
	QStringList timeName;
	for (auto e = Time.begin(); e != Time.end(); ++e)
	{
		timeName.append((*e).right(8)); // 只要时间12:13:14
	}
	QString saveFileName;
	saveFileName = Time[0].left(10) + "_DS18_Temp.csv";
	bool b = JIO::save(saveFilePath + saveFileName, VirtualMap_DS18_Now, timeName, MatDS18B20);
	return b;
}

// 一键原始FBG数据映射
bool OriFBGtoVirtual(QString dir)
{
	// 【1】获取CH通道对应文件
	QStringList TCH = get_FBGT_csv(dir);
	QStringList SCH = get_FBGS_csv(dir);
	// 【2】数据标准化
	mat MatFBGT;
	mat MatFBGS;
	QStringList Time;
	Stand_FBGT_Fix(TCH, MatFBGT, Time);
	Stand_FBGS_Fix(SCH, MatFBGS, Time);// 各通道数据转Mat并排序
	// 【3】虚拟映射算法
	//  温度
	mat outputMatT;
	for (int i = 0; i < 219; ++i) // FBG温度219个
	{
		outputMatT = join_rows(outputMatT, MatFBGT.col(VirtualMap_FBGT_Index[i]));
	}
	//  应力
	mat outputMatS;
	for (int i = 0; i < 90; ++i) // FBG应力90个
	{
		outputMatS = join_rows(outputMatS, MatFBGS.col(VirtualMap_FBGS_Index[i]));
	}
	// 【4】保存文件-波长数据
	QStringList timeName;
	for (auto e = Time.begin(); e != Time.end(); ++e)
	{
		timeName.append((*e).right(8)); // 只要时间12:13:14
	}

	QString saveFileNameT, saveFileNameS;
	saveFileNameT = Time[0].left(10) + "_FBGT_Wave.csv";
	saveFileNameS = Time[0].left(10) + "_FBGS_Wave.csv";

	bool bT = JIO::save(saveFilePath + saveFileNameT, VirtualMap_FBGT_Now, timeName, outputMatT);
	bool bS = JIO::save(saveFilePath + saveFileNameS, VirtualMap_FBGS_Now, timeName, outputMatS);

	// 【5.1】FBG转温度算法
	mat outputMatTemp = outputMatT;
	for (unsigned int j = 0; j < outputMatTemp.n_cols; ++j)
	{
		for (unsigned int i = 0; i < outputMatTemp.n_rows; ++i)
		{
			double value;
			if (j <= 170) // 0.0105 其它
			{
				value = 1.0 / 0.0105*(outputMatTemp(i, j) - VirtualCalibrationWave_201706[j]);
				outputMatTemp(i, j) = value;
			}
			if (j > 170) // 0.0400 立柱
			{
				value = 1.0 / 0.0400*(outputMatTemp(i, j) - VirtualCalibrationWave_201706[j]);
				outputMatTemp(i, j) = value;
			}
		}
	}
	//【5.2】应力换算算法-两个数组
	mat inputTempALL = outputMatT;
	mat inputStress = outputMatS;
	// 套入公式
	for (unsigned int j = 0; j < inputStress.n_cols; ++j)
	{
		for (unsigned int i = 1; i < inputStress.n_rows; ++i)
		{
			// 核心公式
			inputStress(i, j) = ((inputStress(i, j) - inputStress(0, j)) / inputStress(0, j) - 0.920863*(inputTempALL(i, j) - inputTempALL(0, j)) / inputTempALL(0, j)) / 0.776 * 1000000;
		}
		inputStress(0, j) = 0;
	}
	// 【6】保存文件-温度、应力数据
	saveFileNameT = Time[0].left(10) + "_FBGT_Temp.csv";
	saveFileNameS = Time[0].left(10) + "_FBGS_Stress.csv";
	bool bTemp = JIO::save(saveFilePath + saveFileNameT, VirtualMap_FBGT_Now, timeName, outputMatTemp);
	bool bStress = JIO::save(saveFilePath + saveFileNameS, VirtualMap_FBGS_Now, timeName, inputStress);
	return bT && bS && bTemp && bStress;
}




